---
title: "Get To The Point: Summarization with Pointer-Generator Networks 리뷰"
categories:
- Machine Learning
tags:
- Machine Learning
- Deep Learning
- Pointer Generator Network
excerpt: "RNN을 이용한 Summarization"
header:
    overlay_image: https://imgur.com/wipVWWy.png
    overlay_filter: 0.6
---

이 글에서는 [Get To The Point: Summarization with Pointer-Generator Networks](https://research.google/pubs/pub46111/) 논문에 대한 리뷰를 다룹니다. ACL 2017에서 발표되었으며 이 글을 쓴 시점 기준 1915회의 피인용수를 달성하였습니다.

## 1. 요약 문제에 대한 접근

**요약**은 긴 글에서 중요한 정보를 뽑아 짧은 글로 바꾸는 일이다. 이 요약을 자동화하기 위해 여러가지 시도가 있었는데, 과거에는 입력에서 구절을 그대로 들고와서 조합하는 방법을 사용했으나, 당연하게도 좋은 질의 요약을 만들기에는 한계가 있었다.

<div align="center">
<img src="https://imgur.com/0xMzMS9.png" width="60%">
<br><br>
</div>

그래서 RNN을 사용하는 시퀀스 투 시퀀스 모델을 사용하여 요약을 하려는 시도가 이루어져 왔다. 하지만 이 접근에는 몇 가지 문제가 발생한다.

- **부정확한 디테일**
- Corpus 밖에 있는 단어를 처리하지 못하는 **OOV(Out-of-Vocabulary)** 문제
- **자기 반복**

이 논문은 **포인터 생성 네트워크(pointer-generator network)**와 **커버리지 메커니즘(coverage mechanism)**을 도입하여 이 문제들을 해결하는 기여를 하였다.

## 2. 포인터 생성 네트워크

### 2.1. 어텐션과 시퀀스 투 시퀀스 모델

논문에서 만든 모델의 베이스라인이다. 잘 알려진 어텐션을 사용하는 시퀀스 투 시퀀스 모델이니 알고 있다면 2.2로 넘어가자.

**단일 레이어 양방향 LSTM을 사용하는 인코더**는 글의 토큰 $w_i$를 하나씩 받아서 인코더 은닉 상태들 $hi$의 시퀀스를 만든다. **단일 레이어 단방향 LSTM으로 구성된 디코더**는 이전에 만든 단어의 임베딩과 디코더 은닉 상태 $s_t$를 입력으로 받아 다음 단어를 만들어낸다.

어텐션의 경우 **바다나우Bahdanau 어텐션**을 사용한다. 디코더 기준으로 $t$ 단계의 어텐션 분포 $a^t$는 다음과 같다. $v, W_h, W_s, b_{attn}$은 학습 가능한 파라미터이다.

$$
\begin{aligned}
e_i ^t &= v^T \tanh (W_h h_i + W_s s_t + b_{attn}) \\
a^t &= \text{softmax}(e^t)
\end{aligned}
$$

디코더가 현재 어느 부분을 봐야하는 지에 대한 정보가 담긴 어텐션 분포 $a^t$는 인코더 은닉 상태들에 가중합을 적용하여 컨텍스트 벡터 $h_i ^\ast$를 만드는데 사용된다.

$$
h_t ^\ast = \sum _i a_i ^t h_i
$$

이 컨텍스트 벡터는 현재 단계에 소스로부터 어떤 것을 읽었는지에 대한 표현으로, 현재의 디코더 은닉 상태 $s_t$와 합치고concatenate 두 선형 레이어를 거쳐 마침내 단어 분포 $P_{vocab}$을 만든다.

$$
P_{vocab} = \text{softmax}(V'(V[s_t, h_t ^\ast] + b) + b')
$$

학습을 할 때, $t$ 시점의 손실은 목표 단어 $w_t ^\ast$에 대하여 그 단어가 나올 확률의 음의 로그 가능도를 취하여 $$
\text{loss}_t = - \log P_{vocab} (w_t ^\ast)$$로 표현된다. 또한, 전체 시퀀스의 손실은 이를 평균을 한 값이 된다.

$$
\text{loss} = \frac 1 T \sum _{t=0} ^T - \log P_{vocab} (w_t ^\ast)
$$

### 2.2. 포인터 생성 네트워크

포인터 생성 네트워크는 베이스라인 모델만 사용했을 때 나타나는 **OOV 문제**를 해결하기 위해 도입된 구조이다.

<div align="center">
<img src="https://imgur.com/wipVWWy.png" width="100%">
<br><br>
</div>

앞에서 다룬 어텐션 분포 $a^t$와 컨텍스트 벡터 $h_t ^\ast$는 이 장에서도 그대로 사용한다. 이를 기반으로 시점 $t$의 생성 확률(generational probability)는 컨텍스트 벡터 $h_t ^\ast$, 디코더 은닉 상태 $s_t$, 디코더 입력 $x_t$을 기반으로 다음과 같이 정의한다. 벡터 $w_{h^\ast}, w_s, w_x$와 스칼라 $b_{ptr}$은 학습 가능한 파라미턱이고, $\sigma$는 sigmoid 함수이다.

$$
p_{gen} = \sigma (w_{h^\ast} ^T h_t ^\ast + w_s ^T s_t + w_x ^T x_t + b_{ptr})
$$

이 생성 확률 $p_{gen}$은 단어 목록에서 다음 토큰을 만들 확률이고, 반대로 $1-p_{gen}$은 소스에서 단어를 그대로 복사하여 가져올 확률로 사용된다. 각 문서에 대해 확장된 단어 목록(extended vocabulary)을 소스 문서에서 사용되는 단어 목록과 모델에 내재된 단어 목록을 합친 단어 목록이라고 하자. 이 확장된 단어 목록에 대해 확률 분포는 다음과 같이 결정된다.

$$
P(w) = p_{gen} P_{vocab} (w) + (1-p_{gen}) \sum_ {i: w_i=w} a_i ^t
$$

만약 $w$가 언어 모델이 커버하는 단어 목록 밖의 단어였다면, $P_{vocab}(w)=0$이고, 반대로 $w$가 입력된 문서에 나타나지 않는 단어였다면, $\sum _{i:w_i=w} a_i^t=0$임을 확인할 수 있다.

학습 과정에서의 손실 함수는 앞의 장에서의 정의를 그대로 가져올 수 있다.

$$
\text{loss} = \frac 1 T \sum _{t=0} ^T - \log P(w)
$$

### 2.3. 커버리지 메커니즘

여러 줄의 텍스트를 만들 때 **반복** 문제를 해결하기 위해, 다른 논문의 커버리지 모델을 가져와서 도입하였다.

디코더에서 $t$ 시점의 커버리지 벡터 $c^t$는 이전 디코더 시점들에서 사용한 모든 어텐션 분포의 합으로 놓는다.

$$
c^t = \sum _{t'=0 } ^{t-1} a^{t'}
$$

그러면 $c^t$는 지금까지 어텐션 메커니즘에서 어떤 단어들이 많이 사용되었는지에 대한 분포가 된다. $c^0$의 경우 어떤 입력 문서의 단어도 사용되지 않았으므로 영벡터로 놓는다. 이 커버리지 벡터는 어텐션 메커니즘에서 추가적인 입력으로 들어간다. $w_c$는 학습 가능한 벡터 파라미터이다.

$$
e_i ^t = v^T \tanh (W_h h_i + W_s s_t + w_c c_i ^t + b_{attn})
$$

이 구조를 사용하면 어텐션 메커니즘의 현재 결정에 이전까지의 어텐션이 반영되기 때문에, 어텐션 메커니즘이 반복되는 텍스트를 만들어내는 문제를 해결할 수 있다.

반복에 패널티를 주는 커버리지 손실도 정의할 수 있다. $t$ 시점의 커버리지 손실은 그 시점의 어텐션과 커버리지 벡터의 각 원소의 최소의 합으로 구해진다. 어떤 단어가 지금까지 많이 사용되어 해당하는 컨텍스트 벡터의 원소가 높더라도, 커버리지 메커니즘이 잘 학습되면 잘 penalize되어 어텐션 값이 낮아지기 때문에 이 과정이 반영된다.

$$
\text{covloss}_t = \sum _i \min(a_i ^t, c_i ^t)
$$

여기서 커버리지 손실은 $\text{covloss}_t \le \sum _i a_i ^t = 1$로 bounded됨을 알 수 있다. 기계 번역(Machine Translation)에서 사용하는 커버리지 손실의 경우 입력 문장과 목표 출력 문장의 길이가 비슷하기 때문에 입력의 모든 단어가 1회 사용되었다는 가정이 가능하고, 따라서 최종 커버리지 벡터의 각 원소가 1에서 멀어질수록 peanlize한다. 하지만 요약은 그런 가정을 할 수 없기 때문에, 각 시점에서 어텐션과 커버리지 벡터를 고려한 이와 같은 커버리지 손실 함수를 사용하게 되었다.

결론적으로 $t$ 시점의 전체 손실은 $t$ 시점의 기존의 손실에 커버리지 손실과 하이퍼파라미터 $\lambda$의 곱으로 정의된다.

$$
\text{loss}_t = -log P(w_t ^\ast) + \lambda \text{covloss}_t
$$

## 3. 데이터셋

CNN/Daily Mail 데이터셋을 사용한다. 이는 온라인 뉴스 기사(평균 781개의 토큰)와 요약(평균 56개의 토큰, 3.75문장)으로 이루어진 데이터셋이다. 276,226개의 트레이닝 페어, 13,368개의 검증 페어와 11,490개의 테스트 페어로 이루어져 있다. 요약을 다룬 다른 논문의 경우 온라인 뉴스 기사 내용에 어떤 규칙의 전처리를 사용했지만, 이 논문은 어떤 종류의 전처리도 사용하지 않았다.

## 4. 실험

다음의 설정과 테크닉을 적용하였다.

- 256차원의 은닉 상태, 128차원의 단어 임베딩
- 포인터 생성 모델은 50k의 단어 목록 크기를 가짐
- 어떤 종류의 사전학습도 적용하지 않은 단어 임베딩
- Adagrad(learning rate=0.15, initial accumulator=0.1)로 학습
- gradient clipping (maximum norm 2) 적용
- regularization은 미적용
- early stopping 적용 (validation set의 손실을 사용)
- 학습과 테스트 중 입력되는 글의 토큰은 최대 400개로 앞에서부터 잘라냄
- 요약문의 경우 학습은 최대 100 토큰, 테스트는 최대 120 토큰의 임계치 설정
- Tesla K40m GPU, batch size 16
- 테스트는 beam size 4의 beam search 적용

각 모델들에 대해 걸린 시간은 다음과 같다.

1. 단어 목록 크기 50k의 베이스라인 모델 -  4일 14시간 (600,000 iterations)
2. 단어 목록 크기 150k의 베이스라인 모델 - 8일 21시간 (600,000 iterations)
3. 포인터 생성 모델 - 3일 4시간 (230,000 iterations)
4. 커버리지 메커니즘($\lambda =1$)을 적용한 포인터 생성 모델 - 포인터 생성 모델 이후 2시간 (3000 iterations)

별도의 커버리지 손실을 계산하지 않고도 커버리지 메커니즘을 학습하지 않을까 기대했지만, 반복 문제 해결에 전혀 효과적이지 않았다. 또, 처음부터 커버리지 메커니즘의 학습을 적용하면 요약의 학습을 방해해서 이미 학습된 포인터 생성 모델에 커버리지 메커니즘을 학습시켰다.

## 5. 결과

**사용한 지표**

ROGUE 지표에서 목표 요약과 만들어진 요약 사이에서 ROGUE-1은 겹치는 단어의 수, ROGUE-2는 겹치는 bigram(연속한 두 단어)의 수, ROGUE-L은 가장 긴 공통 수열의 길이를 평가한다. 또한, METEOR 지표는 exact match mode의 경우 목표 요약과 모델이 만든 요약에서 단어들 간 exact match 수가 많아질수록, full mode는 동의어 등을 고려한 match의 수가 많아질수록 점수가 높아진다.

**각 지표에 대한 비교**

<div align="center">
<img src="https://imgur.com/XrSJM6d.png" width="100%">
<br><br>
</div>

위에서 학습한 모델들 외에 글의 첫 세 문장을 요약으로 따오는 lead-3 베이스라인과, 글에서 단어들을 직접 뽑아오는 extractive 모델, RNN을 사용한 다른 abstractive 모델 하나씩을 가져와서 구성한 ROGUE와 METEOR 지표를 비교하는 표이다. 이는 몇 가지 관찰을 시사한다:

- 어텐션 메커니즘을 적용한 시퀀스 투 시퀀스 모델의 성능 < 포인터 생성 네트워크 모델의 성능 < 커버리지 메커니즘을 사용한 포인터 생성 네트워크 모델의 성능

- 다른 RNN 모델(abstractive 모델)의 성능 < 포인터 생성 네트워크 모델들의 성능
  
  두 extractive, abstractive 모델은 전처리된 본문을 사용하기 때문에 이 논문의 모델과 직접적인 비교를 하기는 힘들다. 하지만 lead-3 베이스라인 모델을 봤을 때 전처리된 본문을 사용하는 것보다 그대로의 본문을 사용하는 언어 모델이 약간 더 좋은 ROGUE 점수를 받는 것을 감안해도, 그 증가폭보다 abstractive 모델과 포인터 생성 네트워크 모델 지표의 차이가 더 크게 나타난다.

**커버리지 메커니즘은 반복 문제를 해결하는가?**

<div align="center">
<img src="https://imgur.com/rpI20UW.png" width="40%">
<br><br>
</div>

모델이 내놓은 요약문들의 중복을 센 위 자료를 보면 커버리지 메커니즘이 효과적이었다는 점을 확인할 수 있다.

## 6. 결론

요약의 부정확성과 반복 문제를 커버리지 메커니즘을 적용한 포인터 생성 네트워크를 통해 해결하였다. 그 결과 다른 요약을 수행하는 기존의 언어 모델보다 뛰어난 성능을 가진 언어 모델이 만들어졌다.

## 참고 자료

모든 내용과 자료는 [Get To The Point: Summarization with Pointer-Generator Networks](https://research.google/pubs/pub46111/) 논문을 참고하여 만들어졌습니다.