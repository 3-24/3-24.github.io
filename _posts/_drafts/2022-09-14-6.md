---
layout: single
classes: wide
title: 의미론과 재귀 (2)
categories: Programming Language
tags: 
---

$\mathtt{while} \; B \; C$의 표시적 의미론<sup>denotational semantics</sup>적 관계는 다음과 같았다:

$$
\llbracket \mathtt{while} \; B \; C \rrbracket (m) = 
\begin{cases}
\llbracket \mathtt{while} \; B \; C \rrbracket (\llbracket C \rrbracket (m)) & \text{if} \; \llbracket B \rrbracket (m) = \texttt{true} \\
m & \text{if} \; \llbracket B \rrbracket (m) = \texttt{false}
\end{cases}
$$

하지만, 이 관계를 통해 $\mathtt{while} \; B \; C$의 의미를 제대로 나타내지 못한다는 결론을 얻었다. 유한한 반복 안에 이 의미가 끝난다는 보장이 없기 때문이다.

여기서 $\llbracket \mathtt{while} \; B \; C \rrbracket$만 $X$로 바꿔서 적어보자.

$$
X(m) = \begin{cases}
X(\llbracket C \rrbracket (m))  & \text{if} \; \llbracket B \rrbracket (m) = \texttt{true} \\
m & \text{if} \; \llbracket B \rrbracket (m) = \texttt{false}
\end{cases}
$$

이 식을 모든 메모리 $m \in \mathbb{M}$에 대하여 만족하는 함수 X를 찾으면, 그게 $\llbracket \mathtt{while} \; B \; C \rrbracket$의 의미이다. 다시 적으면,

$$
X = \mathcal{F}_{B,C} (X) \quad \text{where} \; \mathcal{F}_{B,C} (X) = \lambda m.
\begin{cases}
X(\llbracket C \rrbracket (m))  & \text{if} \; \llbracket B \rrbracket (m) = \texttt{true} \\
m & \text{if} \; \llbracket B \rrbracket (m) = \texttt{false}
\end{cases}
$$

의 해가 $\llbracket \mathtt{while} \; B \; C \rrbracket$이다.

그러면 이 $X = \mathcal{F}_{B,C} (X)$의 **고정점을 찾는 문제**에 대해 두 가지 의문이 생긴다.

1. 해가 **존재**하는가?
2. 여러 개의 해가 존재한다면, **어떤 해를 고를 것인가**?

이 의문들만 해결된다면, 표시적 의미론에서 재귀 관계에 놓인 문법의 의미를 표현하는 문제가 풀린다. 해의 존재성은, '해가 존재한다'는 공간을 앞으로 정의할 것이고, 해의 선택은 **최소 고정점**<sup>least fixed point</sup>을 정의해서 선택할 것이다. 그러면 다음의 결과가 while의 의미이다.

$$
\llbracket \mathtt{while} \; B \; C \rrbracket = \textbf{lfp} \mathcal{F}_{B,C}
$$

이제 구체적으로 의문들을 어떻게 해결하는 지 알아볼 때이다.

# 의미론과 도메인 이론

우선 $X$가 속하는 의미<sup>semantics</sup>의 공간을 서술하는 이론을 알아야 하는데, 이를 도메인 이론<sup>domain theory</sup>라고 부른다. 이 이론은 완비 부분 순서<sup>complete partial order</sup>로부터 시작한다.

## 부분순서 집합

부분 순서<sup>partial order</sup>는 집합의 포함관계를 떠올리면 된다. 엄밀하게는 집합 $D$에서 정의된 부분순서 $\sqsubseteq$는 다음 성질을 만족하는 관계이다.

1. 반사성<sup>reflexivity</sup>: 모든 $a \in D$에 대해 $ a \sqsubseteq a $이다.
2. 추이성<sup>transitivity</sup>: $a \sqsubseteq b$이고 $ b \sqsubseteq c $이면 $a \sqsubseteq c$이다.
3. 비대칭성<sup>antisymmetry</sup>: $a \sqsubseteq b$이고 $b \sqsubseteq a$이면 $a = b$이다.

부분적인 순서라 불리는 이유는, 집합에서 임의의 두 원소를 골랐을 때 비교가 가능하다는 보장을 하지 않기 떄문이다. 부분순서이면서 일반적인 수의 대소 관계처럼 어떤 두 원소를 골라도 비교가 가능한 경우에는 전순서<sup>total order</sup>라고 부른다.

## 부분순서 집합의 완비성


부분 순서 집합의 **완비성**<sup>completeness</sup>은 해석학에서 **실수의 완비성 공리에서 다루는 그것과 거의 동일하다**. 실수의 완비성 공리는 상계<sup>upper bound</sup>가 있는 공집합이 아닌 부분집합은 언제나 상한<sup>least upper bound</sup>이 있다, 즉 실수가 충분히 빽빽하게 채워져 있다는 내용이다. 완비 부분 순서도 상계가 있는 부분집합이 언제나 상한을 가지는 관계를 의미한다. 엄밀하게는 다음과 같다:

부분 순서 집합 $(D, \sqsubseteq)$에서, 일부 $X \subseteq D$를 가져왔을 때 $d \in D$가 $X$의 **상계**라는 것은 다음을 의미한다.

$$
\forall x \in X, \; x \sqsubseteq d
$$

이런 상계 $d$는 여러 개 있을 수 있다. 만약 $d$가 모든 다른 $X$의 상계보다 작다면, 이를 **상한** 또는 최소상계라고 부르고, $\bigsqcup X$로 표기한다.

부분순서 집합에서 부분집합을 취했을 때 **전순서**이면 이를 **체인**이라고 부른다. 부분순서집합 $(D, \sqsubseteq)$이 완비하다<sup>complete</sup>는 것은, 모든 체인 $X \subset D$의 상한이 집합 $D$에 속함을 의미한다.

$$
\bigsqcup X \in D
$$

## 연속성

두 부분순서 집합 $D_1, D_2$에 대해, 함수 $f: D_1 \to D_2$가 연속이라는 것은, 체인의 상한이 함수에 의해 보존될 때를 의미한다:

$$
\forall \text{chain} \; X \subseteq D_1, \; \bigsqcup f(X) = f (\bigsqcup X)
$$

흥미롭게도, 아무것도 없는 빈 집합도 체인이기 때문에, 이의 상한 $\bot = \bigsqcup \emptyset$이라는, 최소원소가 $D$에 존재한다.

## 의미론과 도메인

프로그래밍 언어에서 메모리의 집합 $\mathbb{M}$은 변수를 값으로 대응시키는 함수들의 집합 $\mathbb{X} \to \mathbb{V}$로 볼 수 있고, 코드의 의미는 이전 글에서 다루었듯, $\mathbb{M} \to \mathbb{M}$에 속한다. 부울 값을 반환하는 식의 의미는 $\mathbb{M} \to \mathbb{B}$가 될 것이다.

- 메모리 도메인 $\mathbb{M} = \mathbb{X} \to \mathbb{V}$
- 코드 의미 도메인 $\llbracket C \rrbracket \in \mathbb{M} \to \mathbb{M}$
- 부울 식의 의미 도메인 $\\llbracket B \rrbracket \in \mathbb{M} \to \mathbb{B}$

우리가 풀고자 하는 $\mathcal{F}_{B,C}: \mathbb{M} \to \mathbb{M}$의 고정점을 찾기 위해서, 이 대상 도메인들이 어떤 좋은 성질을 만족했으면 좋겠고, 그것이 바로 완비부분순서 관계의 존재와 함수의 연속성이다. 완비부분순서를 주기 위해서 몇 가지 테크닉이 필요하다:

### 들어올려진 집합

어떤 집합 $S$에 대해, 새로운 원소 $\bot$을 추가한 집합 $S_{\bot} = S + \\{\bot \\}$을 고려하자. 여기에 순서를

$$
d \sqsubseteq d' \iff (d = d') \lor (d = \bot)
$$

로 주면, $(S_{\bot}, \sqsubseteq)$는 완비부분순서집합이고, $S$의 들어올려진 집합<sup>lifted set</sup>이라 불린다.

## 곱집합

두 완전부분순서 집합 $(D_1, \sqsubseteq_1)$, $(D_2, \sqsubseteq_2)$에 대해, 이들의 곱집합<sup>Cartesian product</sup> $D_1 \times D_2$에서 관계를

$$
(d_1, d_2) \sqsubseteq(d_1 ^\prime, d_2 ^\prime) \iff (d_1 \sqsubseteq_1 d_1^\prime ) \wedge (d_2 \sqsubseteq_2 d_2 ^\prime)
$$

으로 자연스럽게 주었을 때, $(D_1 \times D_2, \sqsubseteq)$ 역시 완전부분순서 집합이다.

## 분리합

두 완전부분순서 집합 $(D_1, \sqsubseteq_1)$, $(D_2, \sqsubseteq_2)$에 대해, 

$$
D_1 + D_2 = \left\{ (d_1, 1) \mid d_1 \in D_1 \right\} \cup \left\{ (d_2, 2) \mid d_2 \in D_2 \right\} \cup \left\{ \bot \right\}
$$

으로 $D_1$과 $D_2$의 분리합<sup>separated sum</sup>을 정의하고,

$$
(d_1, 1) \sqsubseteq (d_1 ^\prime, 1) \iff d_1 \sqsubseteq_1 d_1 ^\prime \\
(d_2, 2) \sqsubseteq (d_2 ^\prime, 2) \iff d_2 \sqsubseteq_2 d_2 ^\prime
$$

으로 관계를 주면 $(D_1 + D_2, \sqsubseteq)$는 완전부분순서 집합이다.

## 연속 함수

두 완전부분순서 집합 $(D_1, \sqsubseteq_1)$, $(D_2, \sqsubseteq_2)$에 대해, $D$를 $D_1$에서 $D_2$로 가는 연속함수들의 집합이라 했을 때,

$$
f \sqsubseteq f^\prime \iff \forall d_1 \in D_1,\; f(d_1) \sqsubseteq_2 f^{\prime}(d_1)
$$

이면 $(D, \sqsubseteq)$는 완전부분순서 집합이다.




# 고정점으로 돌아와서

## 최소 고정점

$(D, \sqsubseteq)$가 부분순서 집합일 때, 함수 $f: D \to D$의 최소 고정점 $\textbf{lfp} f$는 고정점 중 최소인 원소를 의미한다.

$$
f(\textbf{lfp} f) = \textbf{lfp} f \wedge \forall d \in D, \; f(d) = d \implies \textbf{lfp} f \sqsubseteq d
$$

아직은 고정점이 존재하는 지도 모르고, 모든 고정점이 한 고정점과 비교가 가능해서 그 고정점보다 큰 지도 알 수가 없다. 돌고 돌아 우리가 원래 풀고자 했던 $\mathcal{F}_{B,C}$의 최소 고정점을 찾는 문제로 돌아왔다. 그럼에도 완전부분순서 집합, 함수의 연속성과 같은 낯선 개념을 들고 온 이유는 바로바로..

## Kleene의 고정점 정리

$(D, \sqsubseteq)$가 부분순서 집합이고 $f: D \to D$가 연속함수일 때, $f$는 최소고정점이 존재하고, 그 값은

$$
\textbf{lfp}f = \bigsqcup _{i \ge 0 } f^i (\bot)
$$

이다.
