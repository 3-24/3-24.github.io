<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-10-02T22:25:13+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">푹신푹신 후와후와</title><subtitle>수학과 개발을 오가며</subtitle><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><entry><title type="html">norae</title><link href="http://localhost:4000/%EC%9D%BC%EC%83%81/norae/" rel="alternate" type="text/html" title="norae" /><published>2019-10-01T00:00:00+09:00</published><updated>2019-10-01T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9D%BC%EC%83%81/norae</id><content type="html" xml:base="http://localhost:4000/%EC%9D%BC%EC%83%81/norae/">&lt;p&gt;&lt;a href=&quot;https://github.com/3-24/norae&quot;&gt;Github repository&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://3-24.github.io/norae&quot;&gt;구현된 웹 페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;예전에 재미로 만들어봤던 노래방 번호 페이지를 훨씬 멋있게 만들어보았습니다. 오늘 하루종일 시간 가는 걸 모르고 개발해봤네요! 얄팍하던 웹 개발 지식이 어느정도 두터워진 것 같습니다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="개발" /><summary type="html">Github repository</summary></entry><entry><title type="html">poka2019 writeup 1 - Lenstra-Lenstra-Lovász</title><link href="http://localhost:4000/ctf/write-up/LLL/" rel="alternate" type="text/html" title="poka2019 writeup 1 - Lenstra-Lenstra-Lovász" /><published>2019-09-25T00:00:00+09:00</published><updated>2019-09-25T00:00:00+09:00</updated><id>http://localhost:4000/ctf/write-up/LLL</id><content type="html" xml:base="http://localhost:4000/ctf/write-up/LLL/">&lt;blockquote&gt;
  &lt;p&gt;I am not good at Linear Algebra : (
Can you tell me about Lenstra-Lenstra-Lovász lattice basis reduction algorithm?
Add) e=151. This is for make challenge easy.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3-24/write-up/blob/master/2019/poka/Lenstra-Lenstra-Lovasz/enc.txt&quot;&gt;enc.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3-24/write-up/blob/master/2019/poka/Lenstra-Lenstra-Lovasz/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz.sage&quot;&gt;Lenstra-Lenstra-Lovász.sage&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;notations&quot;&gt;Notations&lt;/h2&gt;

&lt;p&gt;Before start, let’s make the notations clear.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; : RSA modulus&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;p,q&lt;/code&gt; : two distinct prime factor of &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt; : RSA encryption exponent
&lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt; : RSA decryption exponent&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dp = d % (p-1)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bits&lt;/code&gt; : bit length of &lt;code class=&quot;highlighter-rouge&quot;&gt;dp&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shiftbits = bits//2 - bits//10&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ct&lt;/code&gt; : ciphertext&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s,x&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;dp = s &amp;lt;&amp;lt; shiftbits + x&lt;/code&gt;. i.e., &lt;code class=&quot;highlighter-rouge&quot;&gt;shiftbits&lt;/code&gt;-length leaked &lt;code class=&quot;highlighter-rouge&quot;&gt;dp&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt; and the remainder part is &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given values are &lt;code class=&quot;highlighter-rouge&quot;&gt;n,e,ct,s&lt;/code&gt;. Of course the objective is getting the plaintext of this RSA encryption.&lt;/p&gt;

&lt;h2 id=&quot;modular-arithmetics&quot;&gt;Modular Arithmetics&lt;/h2&gt;

&lt;p&gt;Since $ed \equiv 1 \mod ((p-1)(q-1)) $,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;ed_p \equiv 1 \mod (p-1).&lt;/script&gt;

&lt;p&gt;Let $ed_p = 1 + (p-1)k $. Then&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e(s \ll \texttt{shiftbits} + x ) = 1 + (p-1)k&lt;/script&gt;

&lt;h2 id=&quot;range-for-bit-and-shiftbits&quot;&gt;Range For &lt;code class=&quot;highlighter-rouge&quot;&gt;bit&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;shiftbits&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;We have bit-length of &lt;code class=&quot;highlighter-rouge&quot;&gt;secret&lt;/code&gt; which is approximately 6/10 bit-length of &lt;code class=&quot;highlighter-rouge&quot;&gt;dp&lt;/code&gt;, which was 614. Therefore &lt;code class=&quot;highlighter-rouge&quot;&gt;bits&lt;/code&gt; is either 1023 or 1024.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1010&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1030&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
1018 610
1019 611
1020 612
1021 613
1022 613
1023 614 (*)
1024 614 (*)
1025 615
1026 615
1027 616
1028 616
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also note that $ed_p = k (p-1)+1$ and $d_p &amp;lt; p-1 $, so $k\le e=151$. So bound of &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; and bit-length of &lt;code class=&quot;highlighter-rouge&quot;&gt;dp&lt;/code&gt; is reasonable.&lt;/p&gt;

&lt;h2 id=&quot;polynomial-modulo-p&quot;&gt;Polynomial Modulo &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;We now have appropriate range for &lt;code class=&quot;highlighter-rouge&quot;&gt;shiftbits&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; to solve&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e(s \ll \texttt{shiftbits} + x ) -1 + k \equiv 0 \mod p&lt;/script&gt;

&lt;p&gt;I used &lt;code class=&quot;highlighter-rouge&quot;&gt;small_roots&lt;/code&gt; in SageMath to use &lt;strong&gt;Coppersmith’s Method&lt;/strong&gt; to solve above this.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;s \ll \texttt{shiftbits} + x + (k-1) e^{-1} \equiv 0 \mod N&lt;/script&gt;

&lt;p&gt;Where $e^{-1}$ is modular inverse of $e$ respect to $N$.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;coppersmith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shiftbits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PolynomialRing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;invE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inverse_mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shiftbits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invE&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# make monic
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;small_roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shiftbits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.44&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epsilon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Therefore we get&lt;code class=&quot;highlighter-rouge&quot;&gt;dp&lt;/code&gt; and also &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; using $p = \frac {e d_p -1} k +1 $. By processing a simple RSA decryption, I could get a flag.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POKA{You_4r3_Crypt0_N00000B_XDD}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3-24/write-up/blob/master/2019/poka/Lenstra-Lenstra-Lovasz/solve.sage&quot;&gt;solve.sage&lt;/a&gt; is the full code.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="CTF" /><category term="write-up" /><category term="LLL" /><category term="Coppersmith" /><category term="RSA" /><category term="CRT" /><summary type="html">I am not good at Linear Algebra : ( Can you tell me about Lenstra-Lenstra-Lovász lattice basis reduction algorithm? Add) e=151. This is for make challenge easy.</summary></entry><entry><title type="html">poka2019 writeup 2 - 강한가 약한가</title><link href="http://localhost:4000/ctf/write-up/ROCA/" rel="alternate" type="text/html" title="poka2019 writeup 2 - 강한가 약한가" /><published>2019-09-25T00:00:00+09:00</published><updated>2019-09-25T00:00:00+09:00</updated><id>http://localhost:4000/ctf/write-up/ROCA</id><content type="html" xml:base="http://localhost:4000/ctf/write-up/ROCA/">&lt;blockquote&gt;
  &lt;p&gt;You have two choice- “Weak” and “Strong”.
What do you want?
&lt;strong&gt;Caution! Maybe “Strong” one will took 2 hours to get your treasure.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3-24/write-up/blob/master/2019/poka/WeakOrStrong/enc.txt&quot;&gt;enc.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3-24/write-up/blob/master/2019/poka/WeakOrStrong/weak-strong.py&quot;&gt;weak-strong.py&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;motivation&quot;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;Me and &lt;a href=&quot;https://github.com/pcw109550&quot;&gt;diff&lt;/a&gt; worked on this problem. At first, we tried some simple number-theoritic calcuations but failed to make a meaningful result. However the interesting fact was the factorization of modulus of prime generating functions.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4014476939...30&amp;lt;49&amp;gt; = 2 · 3 · 5 · 7 · 11 · ... · 109 · 113 · 127

9629474207...70&amp;lt;66&amp;gt; = 2 · 3 · 5 · 7 · 11 · ... · 157 · 163 · 167
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Those were generated by &lt;strong&gt;the product of consecutive primes&lt;/strong&gt;! I searched for this kind of RSA prime generation and &lt;a href=&quot;https://acmccs.github.io/papers/p1631-nemecA.pdf&quot;&gt;a remarkable paper about ROCA(Return of Coppersmith’s Attack)&lt;/a&gt;, noticing this problem would be solved with ROCA.&lt;/p&gt;

&lt;h2 id=&quot;walkthrough&quot;&gt;Walkthrough&lt;/h2&gt;

&lt;p&gt;After that, we found a &lt;a href=&quot;https://ctftime.org/writeup/8805&quot;&gt;ROCA write-up&lt;/a&gt; and tried &lt;a href=&quot;https://sourceforge.net/projects/yafu/&quot;&gt;Yafu&lt;/a&gt;, &lt;a href=&quot;https://github.com/Ganapati/RsaCtfTool&quot;&gt;RsaCTFTool&lt;/a&gt;, and &lt;a href=&quot;https://gitlab.com/jix/neca&quot;&gt;neca&lt;/a&gt; with weak RSA modulus &lt;code class=&quot;highlighter-rouge&quot;&gt;N = 400...579&lt;/code&gt; but failed. So we tried implementation of ROCA with sage refering to the paper.&lt;/p&gt;

&lt;p&gt;It was a hard work. So I kept tried to find ROCA solver but there was no meaningful write-ups and tools for it. In a moment, A flash of idea came to me: “How about trying neca with strong modulus &lt;code class=&quot;highlighter-rouge&quot;&gt;670...77&lt;/code&gt;?”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3-24/write-up/master/2019/poka/WeakOrStrong/images/Screenshot%20from%202019-09-21%2011-58-26.png&quot; alt=&quot;neca result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It took only 64 seconds to get the prime factorization of the modulus,&lt;code class=&quot;highlighter-rouge&quot;&gt;96519019965985189420318021978086209355220104728842768493515285964382881562961 * 69517189020993799354976567194165615733741804094602331588109289689403844859157&lt;/code&gt;. I think it was possible since strong one was written in RSALib format, which was the expected input format of neca. With simple RSA decryption, we captured the flag.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POKA{ROCA_POKA_Return_Of_Coppersmith_Attack}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I uploaded &lt;a href=&quot;https://github.com/3-24/write-up/blob/master/2019/poka/WeakOrStrong/solve.py&quot;&gt;solve.py&lt;/a&gt; for RSA decryption with given factorization.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="CTF" /><category term="write-up" /><category term="ROCA" /><category term="RSA" /><summary type="html">You have two choice- “Weak” and “Strong”. What do you want? Caution! Maybe “Strong” one will took 2 hours to get your treasure.</summary></entry><entry><title type="html">내가 확률을 싫어하는 이유</title><link href="http://localhost:4000/%EC%88%98%ED%95%99/%EC%83%9D%EA%B0%81/WhyHateProb/" rel="alternate" type="text/html" title="내가 확률을 싫어하는 이유" /><published>2019-09-15T00:00:00+09:00</published><updated>2019-09-15T00:00:00+09:00</updated><id>http://localhost:4000/%EC%88%98%ED%95%99/%EC%83%9D%EA%B0%81/WhyHateProb</id><content type="html" xml:base="http://localhost:4000/%EC%88%98%ED%95%99/%EC%83%9D%EA%B0%81/WhyHateProb/">&lt;p&gt;제가 수학을 좋아하는 이유는 &lt;strong&gt;공리&lt;/strong&gt; 위에서 만들어진 학문이기 때문이에요. 약 100~200년 전 칸토어가 세운 집합론의 기초를 시작으로 모든 수학이 공리 위에 놓이게 되었고, 정리의 &lt;strong&gt;참/거짓/나머지 무언가(판별 불가능)&lt;/strong&gt;가 명확하게 결정되었죠.&lt;/p&gt;

&lt;p&gt;확률도 물론 잘 정의됩니다. 유한 또는 가산의 표본 공간 $S$에서 확률 함수 $P:\varphi(S) \to [0,1]$는 다음과 같은 성질을 만족해야 해요:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$P(A\cup B ) = P(A) + P(B) \quad \text{for disjoint} \; A,B \subseteq S$&lt;/li&gt;
  &lt;li&gt;$P(\emptyset) = 0, \quad P(S) = 1$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;물론 일반적인 집합을 다 다루려면 측도론을 도입해야 하는데, 저도 잘 모르고 이 글에서는 중요하지 않으니까 넘어가겠습니다. 요점은 확률 함수는 표본 공간 위에서 &lt;strong&gt;수학적으로 잘 정의된다&lt;/strong&gt;는 거에요!&lt;/p&gt;

&lt;p&gt;근데 제가 접해온 확률 문제는&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;주사위를 두 개 던질 때 합쳐서 12가 나올 확률은 얼마인가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;인데, 여기에서는 어떤 확률 함수도, 표본 공간도 명확하게 제시되어 있지 않아요. 표본 공간이 2부터 12까지의 수들이라고 해도 확률 함수는 극단적으로 $Q:\{2,3,\cdots , 12 \}\to [0,1]$을 다음과 같이 잡아버려도 말이 되거든요:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Q(x) = \begin{cases} 1 &amp; \text{if } x = \{12\} \\ 0 &amp; \text{otherwise} \end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;그러면 $Q ( { 12 } ) = 1$이네요. 하지만 일반적으로는 모든 경우의 수를 생각하고 합이 12가 되는 경우의 비율을 따져 1/36이 답이라고 하잖아요? 그것은 문제에서 각 주사위에 대해 잘 근사하는 확률 분포인 균일 분포를 사용한다는 가정을 했기 때문이에요. 즉, 마치 과학처럼 처음부터 &lt;strong&gt;현실의 문제를 수학적으로 모델링하는 과정을 요구&lt;/strong&gt;하는 거였던겁니다. 이런 생각을 자세히 안해보고 무작정 배우다가 의욕을 잃었던 것 같아요.&lt;/p&gt;

&lt;p&gt;한 마디 더: 예전에는 정보과학의 시간복잡도라는 개념을 거부할 정도로 순수한 수학 자체에 집착했는데 요즘은 많이 나아졌어요. 언젠가는 모델링도 친해질 수 있기를..!&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="확률" /><summary type="html">제가 수학을 좋아하는 이유는 공리 위에서 만들어진 학문이기 때문이에요. 약 100~200년 전 칸토어가 세운 집합론의 기초를 시작으로 모든 수학이 공리 위에 놓이게 되었고, 정리의 참/거짓/나머지 무언가(판별 불가능)가 명확하게 결정되었죠.</summary></entry><entry><title type="html">무제</title><link href="http://localhost:4000/%EC%9D%BC%EC%83%81/190903/" rel="alternate" type="text/html" title="무제" /><published>2019-09-03T00:00:00+09:00</published><updated>2019-09-03T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9D%BC%EC%83%81/190903</id><content type="html" xml:base="http://localhost:4000/%EC%9D%BC%EC%83%81/190903/">&lt;h2 id=&quot;1-workaholic&quot;&gt;1. Workaholic&lt;/h2&gt;

&lt;p&gt;나는 워커홀릭 기질이 있어 보인다. 개강과 함께 사람들을 만나고 중단했던 동아리 활동을 다시 시작하면서 할 일이 많아져서 아직은(?) 하루를 활기차게 보내고 있다. 그러고도 할 일을 더 찾아내서 얹으면서 희열을 느낀다. 특히 올해 해킹 공부를 시작하면서 알고리즘적 문제해결이나 작은 개발 프로젝트만 하던 때와는 새삼 다르게 컴퓨터를 바라보는 시야가 넓어져가는 것 같다. 복잡한 고민들 속에서 내가 집중적으로 하거나 할 예정인 일을 정리해보았다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;암호학 문제 풀이&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최근에 풀고있는 정보보안 암호학 문제셋이 있다. 풀이랑 관련 글은 모두 &lt;a href=&quot;https://github.com/3-24/id0-rsa.pub&quot;&gt;https://github.com/3-24/id0-rsa.pub&lt;/a&gt;를 통해 관리되고 있다. 아직은 쉽지만 수학적인 내용이 많아서 해킹 분야중에 현재 가장 애착이 간다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현대대수 리뷰&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;암호학에서 현대대수에서 배온 내용이 가끔씩 나온다. 군론 앞부분은 자신있지만 뒷부분은 지난 학기에 수강했을 때 놓친 부분이 많아서(기말고사 ㅠㅠ) 다시 살펴봐야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;역공학(reversing), pwn 분야&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;역공학은 관련된 문제를 아직 안풀어봐서 감이 안잡히지만 실행 파일을 읽어서 사람이 이해할 수 있는 소스 코드로 복원하는 과정이고, pwn은 그 소스코드에서 취약점을 찾아내서 공격하는 과정이다. 해킹의 한 분야로 자리잡고 있다. 낮은 레벨의 컴퓨터의 연산 처리가 어떻게 이루어지는지 볼 수 있어서 흥미롭다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TOEFL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해야 하지만 언제나 우선순위에서 미뤄놓고 안하는 그것. 졸업 요건 채우기, 영어 과목 이수 면제 등 ‘하야 하는 것’이지만 나는 ‘하고 싶은 것’을 언제나 먼저 해왔기 때문에 현재 하고 있지는 않다. 학교에서 열어주는 어학 강의나 시험삼아 들어볼려고 한다.&lt;/p&gt;

&lt;h2 id=&quot;2-최적화&quot;&gt;2. 최적화&lt;/h2&gt;

&lt;p&gt;암호 문제를 풀거나 역공학 문서를 볼 때 멍때리는 시간이 대부분이지만 최적화하기는 힘들어보인다. 예컨대 문제를 풀 때도 처음부터 어떤 개념이 사용되었는지 모르는 경우도 있고, 알더라도 해결하는 과정이 매 단계마다 에러가 나기 때문에 의욕을 유지하기 쉽지 않다. 어떻게든 이런 하이 텐션을 유지하는게 최적화의 핵심으로 보인다.&lt;/p&gt;

&lt;h2 id=&quot;3-시간-관리&quot;&gt;3. 시간 관리&lt;/h2&gt;

&lt;p&gt;어떻게든 알고리즘적 문제해결 대회 준비를 할 시간을 넣어보고 싶지만 거기까지는 욕심인 것 같아 포기했다. 대회가 임박하면 팀 연습도 많이 해봐야 할텐데, 시간표도 절대 가볍지는 않기 때문에 도저히 책임을 지고 감당할 자신이 없다. 가끔 관련 글들을 관심을 가지고 읽어보는 걸로 만족해야 할 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;4-블로그에-관한-생각&quot;&gt;4. 블로그에 관한 생각&lt;/h2&gt;

&lt;p&gt;블로그에 글을 못쓰는 만큼 ‘쓰는 의미가 있는 주제’을 물색하고 있다. ‘기본적인 개념은 검색하면 다른 문서에도 잘 적혀있는데, 굳이 내가 써야하나?’ 라는 고민을 계속 한다. 그 중에 내 생각을 가장 쉽게 담을 수 있는 것은 이런 진지한 일상글이기도 하고.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><summary type="html">1. Workaholic</summary></entry><entry><title type="html">타원 곡선 암호 읽을거리</title><link href="http://localhost:4000/%EC%95%94%ED%98%B8%ED%95%99/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/ECC/" rel="alternate" type="text/html" title="타원 곡선 암호 읽을거리" /><published>2019-08-29T00:00:00+09:00</published><updated>2019-08-29T00:00:00+09:00</updated><id>http://localhost:4000/%EC%95%94%ED%98%B8%ED%95%99/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/ECC</id><content type="html" xml:base="http://localhost:4000/%EC%95%94%ED%98%B8%ED%95%99/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/ECC/">&lt;p&gt;&lt;a href=&quot;https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/&quot;&gt;https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;타원 곡선 암호Elliptic Curve Cryptography를 처음 배우는 입장에서 수학적 배경부터 암호의 형성까지 모두 설명이 그야말로 gentle해서 좋았던 글입니다!&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="ECC" /><category term="타원 곡선" /><category term="공유" /><summary type="html">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/</summary></entry><entry><title type="html">RSA</title><link href="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/%EC%95%94%ED%98%B8%ED%95%99/RSA/" rel="alternate" type="text/html" title="RSA" /><published>2019-04-19T00:00:00+09:00</published><updated>2019-04-19T00:00:00+09:00</updated><id>http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/%EC%95%94%ED%98%B8%ED%95%99/RSA</id><content type="html" xml:base="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/%EC%95%94%ED%98%B8%ED%95%99/RSA/">&lt;p&gt;RSA는 어떤 수의 소인수분해는 아주 어렵지만, 반대로 소인수를 곱해서 원래 수를 만드는 것은 쉽다는 성질을 이용한 암호 체계이다. 암호명은 이 암호를 개발한 세 암호학자 Rivest-Shamir-Adelman에서 유래한다.&lt;/p&gt;

&lt;h2 id=&quot;키-형성&quot;&gt;키 형성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;두 소수 $p,q$를 골라서 $n=pq$로 놓는다.&lt;/li&gt;
  &lt;li&gt;$e$를 $\gcd ( \phi (n), e) = 1$이 되도록 뽑는다. $\phi$는 오일러 totient 함수이다.&lt;/li&gt;
  &lt;li&gt;$d = e^{-1}\text{ mod } \phi (n)$ 을 계산한다. modular inverse는 $e$의 선택에 의해 &lt;strong&gt;언제나 존재&lt;/strong&gt;하고, 확장된 유클리도 호제법을 이용해서 아주 &lt;strong&gt;빠른 시간 안에 계산 가능&lt;/strong&gt;하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;암호화&quot;&gt;암호화&lt;/h2&gt;

&lt;p&gt;평문 $m$을 암호화 하는 함수는 다음과 같다:
&lt;script type=&quot;math/tex&quot;&gt;E(m ) \equiv m^e \text{ mod }n&lt;/script&gt;
암호화 함수의 일대일 대응을 유지하기 위해 $m&amp;lt;n$을 가정한다.&lt;/p&gt;

&lt;h2 id=&quot;복호화&quot;&gt;복호화&lt;/h2&gt;

&lt;p&gt;암호문 $c$를 복호화 하는 함수는 다음과 같다:
&lt;script type=&quot;math/tex&quot;&gt;D(c) \equiv c^d \text{ mod } n&lt;/script&gt;
실제로 평문을 암호화했다가 복호화하면 복구 가능하다는 것을 보일 수 있다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned}
D(E(m)) &amp;\equiv E(m) ^d\text{ mod } n \\
&amp;\equiv m^{ed} \text{ mod } n\\
&amp;\equiv m ^{k \phi(n)+1} \text{ mod } n \\
\end{aligned} %]]&gt;&lt;/script&gt;

&lt;p&gt;$\gcd(m,n)  = 1 $ 일 경우, 오일러의 toitient 정리에 의해 $m^{\phi(n)} \equiv 1 \text{ mod } n$이므로 $D(E(m)) \equiv m \text{ mod } n $이다.&lt;/p&gt;

&lt;p&gt;$\gcd(m,n) \ne 1 $일 경우, $n = pq$이므로, $\gcd(m,n)$은 $p$ 또는 $q$이다. 일반성을 잃지 않고 $\gcd(m,n) = p$로 놓자.&lt;/p&gt;

&lt;p&gt;일단 $m^{ed}\text{ mod } p \equiv 0 $이고, $m \text{ mod } p \equiv 0 $이므로 $m \equiv D(E(m)) \text{ mod } p $이다.&lt;/p&gt;

&lt;p&gt;$(m,q) = 1$이므로 페르마의 소정리에 의해 $m^{q-1} \equiv 1 \text{ mod } q $이다. 따라서&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{aligned}
D(E(m)) \equiv m^{k\phi(pq) +1} \equiv m^{k(p-1)(q-1) +1} \equiv (m^{q-1})^{k(p-1)} m \equiv m \text{ mod } q
\end{aligned}&lt;/script&gt;

&lt;p&gt;이다. 따라서 중국인의 나머지 정리에 의해 $D(E(m)) \equiv m \text{ mod } n $이다.&lt;/p&gt;

&lt;h2 id=&quot;사용&quot;&gt;사용&lt;/h2&gt;

&lt;p&gt;$n,e,c$는 공개되어도 상관 없지만, $n$의 소인수인 $p,q$와 복호화에서 사용하는 $d$는 절대 공개해서는 안되고, 추측으로 쉽게 풀릴 수 있는 형태가 되어서도 안된다. 보통 그래서 $p,q$를 아주 큰 소수로 잡으면서 공격에 대비한다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="RSA" /><summary type="html">RSA는 어떤 수의 소인수분해는 아주 어렵지만, 반대로 소인수를 곱해서 원래 수를 만드는 것은 쉽다는 성질을 이용한 암호 체계이다. 암호명은 이 암호를 개발한 세 암호학자 Rivest-Shamir-Adelman에서 유래한다.</summary></entry><entry><title type="html">Oracle Padding Attack</title><link href="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/%EC%95%94%ED%98%B8%ED%95%99/opa/" rel="alternate" type="text/html" title="Oracle Padding Attack" /><published>2019-04-15T00:00:00+09:00</published><updated>2019-04-15T00:00:00+09:00</updated><id>http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/%EC%95%94%ED%98%B8%ED%95%99/opa</id><content type="html" xml:base="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/%EC%95%94%ED%98%B8%ED%95%99/opa/">&lt;h2 id=&quot;환경&quot;&gt;환경&lt;/h2&gt;
&lt;h3 id=&quot;cbc&quot;&gt;CBC&lt;/h3&gt;

&lt;p&gt;이 글에서 집중할 부분은 CBC의 복호화 과정이다.&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/ECB_decryption.svg/1920px-ECB_decryption.svg.png&quot; width=&quot;100%&quot; /&gt;
&lt;figcaption&gt; Figure 1. CBC 암호의 복호화 과정&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;CBC 암호는 블록 단위로 암호화를 하듯, 복호화 과정에서도 블록 단위로 다음의 XOR 연산을 수행한다:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_i = D_k (C_i) \oplus C_{i-1} \\ C_0 = IV&lt;/script&gt;

&lt;p&gt;즉 $i$번째 블록의 복호화은 $i$번째 블록을 풀어내는 복잡한 연산의 결과에 $C_{i-1}$을 XOR한다.&lt;/p&gt;

&lt;h3 id=&quot;decryption-oracle&quot;&gt;Decryption Oracle&lt;/h3&gt;

&lt;p&gt;Oracle Padding Attack은 CBC 암호의 decryption oracle이 주어졌을 때 사용할 수 있는 공격 기법이다. Decryption oracle이란 내가 암호문을 보냈을 때 평문으로 바꿔주는 역할을 말하는 것으로, 대개 decryption oracle에 접근할 때는 관리자가 아닌 이상 암호문을 넣었을 때 평문을 출력받지 못하고 &lt;strong&gt;계산 가능 여부&lt;/strong&gt;만 확인할 수 있다. 만약 정상적인 암호문을 넣었다면 정상적으로 작동하겠지만, 형식에 맞지 않은 암호문을 넣었을 때 에러를 뱉어낸다.&lt;/p&gt;

&lt;h2 id=&quot;패딩&quot;&gt;패딩&lt;/h2&gt;

&lt;p&gt;블록 암호의 경우에는 블록 단위로 암호화를 시키기 때문에 블록 단위로 나누어지지 않을 경우가 발생한다. 따라서 남는 공간을 대충 채우는 과정이 필요하고, 다음의 규칙을 따른다:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;n바이트의 공간이 남으면 n으로 남은 n바이트를 모두 채워버린다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어 블록 암호가 16바이트씩 쪼개서 암호화를 시킨다고 하자. 만약에 암호화시킬 문장이 30바이트였다면, 16바이트로 한 블록을 만들고 남은 14바이트에 ‘0x02’, ‘0x02’를 붙여서 16바이트로 만들어서 블록을 저장한다.&lt;/p&gt;

&lt;p&gt;만약에 평문이 정확히 32바이트라도 16바이트 블록 두 개를 만든 후 혼돈을 막기 위해 ‘0x10’, 즉 16짜리 바이트 16개로 모두 채운 블록을 하나 더 만들어버린다. 그러면 마지막 블록은 ‘0x10101010101010101010101010101010’가 될 것이다.&lt;/p&gt;

&lt;p&gt;Decryption Oracle은 형식에 맞지 않은 암호문을 넣었을 때 에러를 출력한다. 즉, 입력에 대해 decryption oracle의 복호화 결과가 적합하지 않은 패딩을 가진다면 에러인데, 이 틈을 파고드는 공격 방식이 이번 글에서 소개하는 Oracle Padding Attack이다.&lt;/p&gt;

&lt;h2 id=&quot;공격-방법&quot;&gt;공격 방법&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;CBC 암호 방식에서 decryption oracle이 주어져 있을 때 ‘패딩’이라는 문법에 집중하는 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;먼저 타깃이 될 암호문이 주어지고, 공격자의 목적은 이 암호문의 평문이다. 편의상 16바이트 단위의 CBC이고 암호문은 32바이트라고 해보자. 이 때 나머지 바이트는 일정하게 유지한 채로 16번째 바이트를 바꿔가면서 입력을 넣는다. 다 해봤자 1바이트는 256가지 경우밖에 없으므로 순식간에 처리된다.&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/opa01.png&quot; width=&quot;100%&quot; /&gt;
&lt;figcaption&gt; Figure 2. Oracle Padding Attack&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;대부분은 에러를 decryption oracle에서 전달받을 것이다. 그런데 딱 하나, decryption oracle에서 에러를 뱉지 않는 경우가 존재한다.&lt;/p&gt;

&lt;p&gt;이 때 바꿔서 입력한 바이트를 ‘0xb3’이라고 해보자. 그러면 이게 의미하는 것은 &lt;strong&gt;우연히 패딩이 틀리지 않았을 경우&lt;/strong&gt;이다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_2' = D_k ( C_2) \oplus C_1'&lt;/script&gt;

&lt;p&gt;즉, 입력한 바이트를 통해 연산한 결과가 ‘0x01’, 길이 1짜리 패딩이라는 뜻이다. 따라서 $D_k(C_2)$의 마지막 두 자리를 추정할 수 있다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;a \oplus b = c \implies a \oplus b \oplus b = c \oplus b \implies a = c \oplus b&lt;/script&gt;

&lt;p&gt;그러니까 ‘0xb3’과 ‘0x01’을 xor한 ‘0xb2’가 $D_k (C_2)$의 마지막 두 자리이다.&lt;/p&gt;

&lt;p&gt;이런 방법을 앞의 자리에도 적용할 수 있다. 이번에는 ‘0x02’가 두 번 나오도록 유도해야 하기 때문에 16번째 바이트를 ‘0xb2’에 ‘0x02’를 xor해서 ‘0xb0’로 고정시키고, 15번째 바이트에 대해서 모든 경우를 실험해본다. 만약 에러가 나타나지 않으면, 그 바이트를 통해 또 $D_k (C_2)$의 마지막에서 세번째, 네번째 자리를 찾아낼 수 있다.&lt;/p&gt;

&lt;p&gt;이 방법을 16번 실행해서 $D_k(C_2)$ 전체를 알아낼 수 있다. 이말은 즉 원래의&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_2 = D_k (C_2) \oplus C_1&lt;/script&gt;

&lt;p&gt;을 계산할 수 있게 되었다는 것을 의미하고 평문를 추정할 수 있다.&lt;/p&gt;

&lt;p&gt;이 예시에서는 두 블록 짜리 암호문을 예로 들었는데, 블록이 많아도 문제가 전혀 되지 않는다. 뒷부분 블록은 앞의 복호화에 영향을 주지 않기 때문에 그냥 빼버리고 예시에서 했던 것처럼 마지막 블록을 반복해서 찾아내면 된다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="블록 암호" /><category term="패딩" /><summary type="html">환경 CBC</summary></entry><entry><title type="html">크기 4인 군의 분류</title><link href="http://localhost:4000/%EC%88%98%ED%95%99/order4_subgp/" rel="alternate" type="text/html" title="크기 4인 군의 분류" /><published>2019-04-12T00:00:00+09:00</published><updated>2019-04-12T00:00:00+09:00</updated><id>http://localhost:4000/%EC%88%98%ED%95%99/order4_subgp</id><content type="html" xml:base="http://localhost:4000/%EC%88%98%ED%95%99/order4_subgp/">&lt;p&gt;모든 크기 4인 군은 순환군 $Z_4$나 Klein-4군 $V_4$와 동형isomorphic다.&lt;/p&gt;

&lt;h2 id=&quot;order-4인-원소가-있는-경우&quot;&gt;Order 4인 원소가 있는 경우&lt;/h2&gt;

&lt;p&gt;그 원소를 $x$로 놓았을 때 $ \vert \langle x \rangle \vert $은 이미 크기가 4이기 때문에 $x$로만 생성되는 군이 이미 모든 공간을 채워버린다. 따라서 $Z_4$.&lt;/p&gt;

&lt;h2 id=&quot;그렇지-않은-경우&quot;&gt;그렇지 않은 경우&lt;/h2&gt;

&lt;p&gt;그렇다면 1을 제외한 모든 원소의 order가 2일 것이다(Order 1인 원소는 1밖에 없기 때문에 세 자리가 남으므로). 다시 말해, 대상 군을 $G$로 놓았을 때  $G = {1,x,y,z}$ 의 형태로, 서로 다른 $x,y,z$에 대해 $\vert x \vert=\vert y\vert=\vert z\vert = 2 $를 만족한다.&lt;/p&gt;

&lt;p&gt;남은 연산 관계를 채우기 위해서는 직접 경우를 제거해나가면 된다. $xy$에 집중하면,&lt;/p&gt;

&lt;p&gt;$xy=1$일 때 $y$는 $x$의 역원이 되기 때문에 $y=x$가 되므로 모순이다.&lt;/p&gt;

&lt;p&gt;$xy = x$일 때 양변의 왼쪽에 $x$를 곱하면 $x^2 = 1$이므로 $y = 1$이 된다. 모순&lt;/p&gt;

&lt;p&gt;$xy = y$도 마찬가지로 모순이다.&lt;/p&gt;

&lt;p&gt;따라서 $xy = z$인 경우만 남는다.&lt;/p&gt;

&lt;p&gt;이런 과정을 모두 반복하면 다음의 군표(group table)을 얻을 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$x$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$y$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$z$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$x$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$y$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$z$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$x$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$x$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$z$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$y$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$y$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$y$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$z$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$x$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$z$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$z$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$y$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$x$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 연산은 닫혀있으면서 associative이고, 항등원이 잘 작동하고 역원이 언제나 존재하므로 $G$는 군이고, 사실 Klein 4 군과 동형이다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="군" /><summary type="html">모든 크기 4인 군은 순환군 $Z_4$나 Klein-4군 $V_4$와 동형isomorphic다.</summary></entry><entry><title type="html">유리수의 조밀성</title><link href="http://localhost:4000/%EC%88%98%ED%95%99/%EC%9C%A0%EB%A6%AC%EC%88%98%EC%9D%98-%EC%A1%B0%EB%B0%80%EC%84%B1/" rel="alternate" type="text/html" title="유리수의 조밀성" /><published>2019-03-24T00:00:00+09:00</published><updated>2019-03-24T00:00:00+09:00</updated><id>http://localhost:4000/%EC%88%98%ED%95%99/%EC%9C%A0%EB%A6%AC%EC%88%98%EC%9D%98-%EC%A1%B0%EB%B0%80%EC%84%B1</id><content type="html" xml:base="http://localhost:4000/%EC%88%98%ED%95%99/%EC%9C%A0%EB%A6%AC%EC%88%98%EC%9D%98-%EC%A1%B0%EB%B0%80%EC%84%B1/">&lt;p&gt;임의의 서로 다른 두 실수 사이에 유리수가 존재합니다. 이를 유리수의 조밀성이라고 하고 본 글에서는 이것의 해석학적 접근을 소개하려 합니다.&lt;/p&gt;

&lt;h2 id=&quot;실수와-cut&quot;&gt;실수와 cut&lt;/h2&gt;

&lt;p&gt;실수는 cut의 집합으로 정의할 수 있습니다. 그리고 이 cut은 사실 어떤 유리수의 집합인데, 다음 성질들을 만족해야 해요:&lt;/p&gt;

&lt;p&gt;$\alpha \subset \mathbb{Q}$가 cut이려면&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\alpha \ne \mathbb{Q}$이고 $ \alpha \ne \emptyset $이다.&lt;/li&gt;
  &lt;li&gt;모든 $x \in \alpha$에 대하여 유리수 $ y &amp;lt; x $일 때 $ y \in \alpha $이다.&lt;/li&gt;
  &lt;li&gt;모든 $x \in \alpha$에 대하여 $x&amp;lt;y$ 인 $y \in \alpha$가 존재함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉 이렇게 $- \infty$부터 어떤 수까지 (열린) 범위를 cut이라고 정했어요. 그리고 이런 cut들을 다 모아놓으면 실수가 되는 것이죠. 연산도 수학자들이 잘 정의해서 우리가 아는 사칙연산이 모두 정상적으로 작동합니다.&lt;/p&gt;

&lt;p&gt;순서 관계는 어떨까요? cut의 포함 관계를 이용해서 정의하면 우리가 아는 일반적인 순서 관계의 성질을 그대로 만족합니다. 즉, $\alpha \subseteq \beta$ 이면 그냥 $\alpha \le \beta$라고 해버리는 거에요.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha \le \beta \quad \text{if} \quad \alpha \subseteq \beta&lt;/script&gt;

&lt;h2 id=&quot;실수-안의-유리수&quot;&gt;실수 안의 유리수&lt;/h2&gt;

&lt;p&gt;눈치가 빠르면 사실 $\mathbb{Q} \not\subset \mathbb{R}$  임을 확인했을 거에요. 왜냐하면 cut이 $\mathbb{Q}$의 부분집합이었기 때문이죠. 그런데 유리수라는 개념은 실수에서도 중요한 역할을 합니다. 그래서 수학자들은 엄밀하게 실수 위에서 유리수를 따로 정의했어요.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\mathrm{For} \; q \in \mathbb{Q}, \quad q^\ast := \{ x \in \mathbb{Q} : x &lt; q \}​ %]]&gt;&lt;/script&gt;

&lt;p&gt;그러면 $q^\ast$는 cut이에요. 증명은 쉬우니까 넘어갈게요. 이렇게 생긴 애들을 싹 모아서&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbb{Q}^\ast := \{q^\ast \in \mathbb{R} : q \in \mathbb{Q} \}&lt;/script&gt;

&lt;p&gt;이렇게 모아놓으면 이 $\mathbb{Q}^\ast \subseteq \mathbb{R} $은 원래 알던 유리수의 성질을 그대로 만족합니다. 앞으로도  $\mathbb{Q}$와 $\mathbb{Q} ^\ast$를 구별해서 사용한다는 점 유의해주세요.&lt;/p&gt;

&lt;h2 id=&quot;실수-사이의-유리수&quot;&gt;실수 사이의 유리수&lt;/h2&gt;

&lt;p&gt;이야기가 길어졌네요. ‘주어진 서로 다른 두 실수 사이에 유리수가 존재할까?’는 실수의 정의로부터 확인됩니다.&lt;/p&gt;

&lt;p&gt;서로 다른 실수 $\alpha, \beta $가 주어졌으면 순서 관계의 정의에 의해 $\alpha \subset \beta$입니다. 그러니까 $q \not\in \alpha$이고 $q \in \beta$인 유리수 $q\in \mathbb{Q}$가 존재한다는 거에요. 이런 $q$에 대해 $q^\ast \in \mathbb{Q}^\ast$를 생각해보면,&lt;/p&gt;

&lt;p&gt;$q \notin \alpha$이기 때문에 모든 $a \in \alpha$에 대해 $a &amp;lt; q$이므로 $\alpha \subseteq q^ \ast $입니다.  만약 $ a \not&amp;lt; q$였다면 cut의 두 번째 조건에 의해서 모순이었겠죠?&lt;/p&gt;

&lt;p&gt;또, $q \in \beta$이므로 $q$보다 작은 모든 유리수가 cut의 두 번째 조건에 의해 $\beta$에 들어갑니다. 따라서 $q^\ast \subset \beta$이죠. $q^\ast \ne \beta$인 이유는 $q \not\in q^\ast$이지만 $q \in \beta$이기 때문입니다.&lt;/p&gt;

&lt;p&gt;우리는 따라서 $\alpha \subseteq q^\ast \subset \beta$를 얻어냈습니다. 하지만 ‘사이’라는 것을 보이기에는 부족하죠. $q^\ast = \alpha$이면 어떡하죠?&lt;/p&gt;

&lt;p&gt;저도 쓰다가 당황했는데요, 그래도 상관 없는게 $\alpha &amp;lt; (\alpha + \beta) / 2 $를 잘 이용하면 되요. 그러니까 $\alpha, \beta$대신 $\frac {\alpha + \beta} 2 , \beta$에서 위 과정을 반복하면 또 $\frac {\alpha + \beta} 2 \subseteq p^\ast \subset \beta$를 만족하는 유리수 $p ^ \ast \in \mathbb{Q}^\ast $가 존재하기 때문에 $\alpha \subset p^\ast \subset \beta $입니다.&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;이 내용을 더 공부하고 싶다면 Walter Rudin의 Principle of Mathematical Analysis 1단원을 읽어보세요. 불친절하지만 많은 내용을 담고 있는 유명한 해석학 책입니다. 여기서 정의한 cut이 어떻게 실수가 되는지 더 자세하게 알 수 있을 거에요.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="유리수" /><category term="실수" /><category term="해석학" /><summary type="html">임의의 서로 다른 두 실수 사이에 유리수가 존재합니다. 이를 유리수의 조밀성이라고 하고 본 글에서는 이것의 해석학적 접근을 소개하려 합니다.</summary></entry></feed>