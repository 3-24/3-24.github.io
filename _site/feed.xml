<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-10-07T18:03:25+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Three Dash Two Four</title><subtitle>수학과 개발을 오가며</subtitle><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><entry><title type="html">2020년 여름학기 몰입캠프 후기</title><link href="http://localhost:4000/scribbles/madcamp-review/" rel="alternate" type="text/html" title="2020년 여름학기 몰입캠프 후기" /><published>2020-08-08T00:00:00+09:00</published><updated>2020-08-08T00:00:00+09:00</updated><id>http://localhost:4000/scribbles/madcamp-review</id><content type="html" xml:base="http://localhost:4000/scribbles/madcamp-review/">&lt;p&gt;봄학기 종강을 하자마자 카이스트에서 여름학기로 열리는 몰입캠프에 참여했기 때문에 한동안 정말 바빴다. 어제 몰입캠프 종강을 한 지금, 이 캠프에 참여하면서 얻은 것들을 정리해보고자 한다. 이 후기를 쓰고 있는 나는 카이스트 전산학부지만, 타대생과 컴공이 아닌 다른 전공을 하고 있는 수강생도 많이 볼 수 있었다.&lt;/p&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://madcamp.io/&quot;&gt;몰입캠프 메인페이지&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/document/d/1flSaJ4kGRzkpxTTlRNqA7bOC0oI7idQR3PXPnMt9b-g/edit&quot;&gt;2020년 여름학기 몰입캠프 강의계획서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실라버스를 보면 알 수 있듯, 완전히 개발 프로젝트 중심의 수업이다. 4주동안 각 주마다 프로젝트 하나를 2~3인 팀을 구성하여 진행하게 된다. 매 주 프로젝트 발표를 마친 후 투표를 하여 금주의 픽으로 선택되면 전체 수강생들 앞에서 한 번 더 발표를 하게 되는 영광을 누릴 수 있다. 금주의 픽 발표가 끝나면 스타트업 관계자가 들려주는 생생한 창업 스토리나 프로젝트에 사용될만한 기술, 개발 방법론 등을 들을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;프로젝트&quot;&gt;프로젝트&lt;/h2&gt;

&lt;p&gt;프로젝트를 위해 20명으로 구성된 각 반마다 실습실 하나를 사용하게 된다. 인당 모니터 두 대와 쓸만한 성능의 컴퓨터를 사용하게 된다.&lt;/p&gt;

&lt;p&gt;이 수업을 듣기 전에 나는 개발 중에 사용한 대부분의 프로그래밍 언어나 프레임워크로 개발한 경험은 없지만, CTF 문제를 풀어보면서 기본적인 서버와 데이터베이스 개념과 몇 가지 문법을 이용해본 적이 있는 정도였다. 그래서 사용하는 기술에 대한 적응은 빠른 편이었던 것 같다. 혼자서는 한 주 만에 절대 하지 못했을 것 같지만 주변에 물어볼 사람도 많고 다 같이 몰입하며 열심히 하는 분위기가 형성되기 때문에 나도 놀랄 정도로 많은 기술들을 공부하고 적용해볼 수 있었다.&lt;/p&gt;

&lt;p&gt;각 프로젝트에서 세부적으로 했던 일들은 다음과 같다. 자랑할만 하지는 않지만 프로젝트 소스코드도 같이 올려놓았다.&lt;/p&gt;

&lt;h3 id=&quot;1주차&quot;&gt;1주차&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/3-24/madcamp1&quot;&gt;영석이의 하루 Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;안드로이드 앱 개발을 한다. 탭1에는 사용자의 연락처 목록을 받아와 연락처 화면을 구성하고, 탭2에는 사진을 받아와서 갤러리 화면을 구성한다. 마지막 탭3은 자유 주제로, 나는 날씨 API에서 현재 위치하고 있는 지역의 날씨 정보를 받아와 일기예보를 보여주는 화면을 만들었다. 사용하는 언어나 프레임워크는 자유이고, 나를 포함한 대부분의 사람들은 기본 안드로이드 자바 프로그래밍을 하였다.&lt;/p&gt;

&lt;h3 id=&quot;2주차&quot;&gt;2주차&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/3-24/madcamp2&quot;&gt;밤편지 프런트엔드 Github&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/3-24/madcamp2_backend&quot;&gt;밤편지 백엔드 Github&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;안드로이드 앱 개발은 그대로이지만, 서버와 데이트베이스 기술을 적용해야 한다. 탭1과 탭2의 형식은 연락처와 갤러리로 동일하나 서버와 상호작용하는 부분을 추가해야 한다. 나는 1주차 때 했던 탭1 탭2 구성을 똑같이 하고 싶지 않아서 간단한 SNS 서비스를 만들어 탭1을 친구 목록, 탭2를 피드로 대체하였다. 새로운 개발 프레임워크를 경험하고 싶어서 React Native를 이용해보았고, 백엔드 서버는 NodeJS와 MySQL 데이터베이스를 사용하였다.&lt;/p&gt;

&lt;h3 id=&quot;3주차&quot;&gt;3주차&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/CatDominatesWorld/CatDominatesWorld&quot;&gt;고양이가세계를지배한다냥 프런트엔드 Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/CatDominatesWorld/CatDominatesWorld-backend&quot;&gt;고양이가세계를지배한다냥 백엔드 Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://github.com/CatDominatesWorld/CatDominatesWorld/blob/master/asset/demo.png?raw=true&quot; width=&quot;90%&quot; /&gt;
    &lt;figcaption&gt; Figure 1. 위키피디아 COVID-19 문서에 적용한 모습 &lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;자유 주제&lt;/strong&gt;. 나는 웹 페이지에 표시되는 모든 텍스트를 ‘냥’과 ‘meow’로 바꾸고, 모든 사진에서 얼굴을 인식하면 고양이 얼굴로 바꾸는 크롬 익스텐션을 만드는 프로젝트를 하였다. 크롬 익스텐션 쪽은 HTML/CSS와 Javascript를 이용하여, 그리고 자연어 처리와 얼굴 인식을 하여 변환 부분을 담당하는 백엔드 서버는 Python 3기반으로, 통신은 Flask, 이미지 프로세싱은 OpenCV, 자연어 처리는 konlpy와 nltk 라이브러리, 얼굴 인식은 카카오 Vision API를 사용하였다.&lt;/p&gt;

&lt;h3 id=&quot;4주차&quot;&gt;4주차&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;자유 주제&lt;/strong&gt;. Unreal Engine을 이용해 3차원 잠입 액션 게임을 만들었다. 언리얼 엔진은 애니메이션 하나만 추가해도 150MB만큼의 용량을 요구하기 때문에(…) Github를 통해 관리하다가 포기했다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/img/phantom_sight.png&quot; width=&quot;90%&quot; /&gt;
    &lt;figcaption&gt; Figure 2. Phantom Sight - 3차원 잠입 액션 게임 &lt;/figcaption&gt;
&lt;/div&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;한 달 동안 같은 실습실에서 밤을 새면서 개발을 하기 때문에 다 같이 친해지게 된다. 식사나 술자리를 자주 가졌고, 심지어 엠티를 다녀오기도 했다. 정말 착하고 좋은 다양한 사람들을 만나서 4주 내내 행복했다. 신청을 할 때를 돌이켜 생각해보면 정말 여러가지 동기가 복합적으로 작용했었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 명이 참여하는 개발 프로젝트를 경험하고, 개발 역량을 키우기 위해서&lt;/li&gt;
  &lt;li&gt;방학을 의미있게 보내고 싶어서&lt;/li&gt;
  &lt;li&gt;개발에 관심이 있는 새로운 사람을 만나고 싶어서&lt;/li&gt;
  &lt;li&gt;스타트업 생태계에 대한 생생한 정보를 듣고 싶어서&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결과적으로 내가 기대했던 것들을 다 얻을 수 있었고, 정말 잊지 못할 방학이 될 것 같다. COVID-19로 어려움이 있음에도 불구하고 이런 기회를 준 교수님들, 강연자분들과 같은 공간에서 같이 밤을 샌 반 동료들에게 감사한다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Scribbles" /><category term="madcamp" /><summary type="html">봄학기 종강을 하자마자 카이스트에서 여름학기로 열리는 몰입캠프에 참여했기 때문에 한동안 정말 바빴다. 어제 몰입캠프 종강을 한 지금, 이 캠프에 참여하면서 얻은 것들을 정리해보고자 한다. 이 후기를 쓰고 있는 나는 카이스트 전산학부지만, 타대생과 컴공이 아닌 다른 전공을 하고 있는 수강생도 많이 볼 수 있었다.</summary></entry><entry><title type="html">단일프로세서 스케줄링</title><link href="http://localhost:4000/system/scheduler-policy/" rel="alternate" type="text/html" title="단일프로세서 스케줄링" /><published>2020-06-20T00:00:00+09:00</published><updated>2020-06-20T00:00:00+09:00</updated><id>http://localhost:4000/system/scheduler-policy</id><content type="html" xml:base="http://localhost:4000/system/scheduler-policy/">&lt;p&gt;사용할 수 있는 CPU는 유한하지만 운영체제는 여러 개의 일task를 한꺼번에 작동시켜야 한다. 그래서 운영체제에서 일이 CPU를 점유하는 시간을 관리해주는 부분이 필요한데, 이를 스케줄러scheduler라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;performace-metric&quot;&gt;Performace Metric&lt;/h2&gt;

&lt;p&gt;어떤 방식의 스케줄링을 사용하는 것을 고민하기 전에, 그 스케줄링이 얼마나 효율적인지를 나타내는 지표들을 정리해보았다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;throughput: 시간당 처리가 끝나는 일의 수&lt;/li&gt;
  &lt;li&gt;turnaround time: 일이 완전히 처리될 때까지 걸리는 시간 ($T_{fin} - T_{arrival}$)&lt;/li&gt;
  &lt;li&gt;response time: 일이 처음 반응하기까지 걸리는 시간 ($T_{response} - T_{arrival}$)&lt;/li&gt;
  &lt;li&gt;waiting time: ready, wait상태에서 일이 기다린 시간의 합&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;특정 스케줄러로 여러 일을 처리했을 때 위 네 지표가 낮다면 그것은 효율적인 스케줄러이다.&lt;/p&gt;

&lt;p&gt;문제의 단순화를 위해 프로세서가 하나만 있는 경우에 대해서만 다룬다.&lt;/p&gt;

&lt;h2 id=&quot;1-fifo&quot;&gt;1. FIFO&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;먼저 오는 일을 먼저 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가장 먼저 생각해볼만한 방법이다. 먼저 오는 일을 먼저 처리한다. (First-In-First-Out)&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler01.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. FIFO Scheduling
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;하지만 시간이 오래 걸리는 일이 먼저 처리되고, 시간이 적게 걸리는 일에 나중에 처리되면 성능이 급격히 하락한다. 예를 들면 P1, P2, P3, P4가 시간이 각각 20, 4, 3, 3만큼 거리는 일이라고 하고, 이들이 시간 0에 P1, P2, P3, P4 순서대로 FIFO 스케줄러에 도달했다고 하자. 그러면 Figure 1과 같이 스케줄링될 것이다. 그러면 총 turnaround time=20+24+27+30=91, 총 response time=0+20+24+27=71, 총 waiting time=0+20+24+27=71이다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler02.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 2. Optimal Scheduling
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;만약에 Figure 2와 같이 스케줄링되었다면 총 turnaround time=3+6+10+30=49, 총 response time=0+3+6+10=19, 총 waiting time=0+3+6+10=19가 된다. 이와 같이 FIFO 방식으로 스케줄링 했을 때 오래 걸리는 일이 나머지 일의 처리를 지연시키는 상황을 convoy effect라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스케줄러의 계산량이 적다. 이전 일의 처리가 끝날 때마다 ready queue에서 첫 번째 일을 running state로 보내버리면 된다.&lt;/li&gt;
  &lt;li&gt;같은 이유로 구현이 간단하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;성능이 나쁘다. convoy effect에 의해 평균 response time, 평균 turnaround time, 평균 waiting time 모두 높다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-shortest-job-first-sjf&quot;&gt;2. Shortest Job First (SJF)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;남은 시간이 가장 짧은 일을 먼저 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler02.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 2. SJF Scheduling (Recall)
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Figure 2와 같이, &lt;strong&gt;남은 시간이 가장 짧은 일을 먼저 처리하는 방식&lt;/strong&gt;이다. 가능한 스케줄링 방식 중에 평균 waiting time이 가장 낮다. 하지만 언제나 시간이 적게 걸리는 일을 시간이 많이 걸리는 일보다 먼저 처리하기 때문에, 시간이 적게 걸리는 일이 계속 쿼리될 경우 시간이 많이 걸리는 일이 먼저 쿼리되었음에도 불구하고 계속 처리가 지연된다. 이런 현상을 &lt;strong&gt;starvation&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지표 상 성능이 좋다. 최소의 평균 waiting time을 보장하고, 평균 response time, 평균 turnaround time 모두 빠른 편에 속한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;starvation이 발생한다.&lt;/li&gt;
  &lt;li&gt;완벽한 구현이 불가능하다. 일반적으로 스케줄러가 특정 일을 처리하기 전에 그 일이 얼마나 걸리는 지 확인할 방법이 없다. 그래서 그 일이 얼마나 걸릴지 이전 일들이 걸린 시간을 통해 유추하는 방법을 사용한다. 스케줄링은 운영체제에서 자주 일어나는 일이기 때문에 높은 계산량을 요구하는 유추 알고리즘은 사용할 수 없고, 이전 일들이 걸린 시간들의 단순한 선형 관계 정도의 유추 전략이 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;starvation을-해결하는-방법&quot;&gt;Starvation을 해결하는 방법&lt;/h3&gt;

&lt;p&gt;SJF 스케줄링은 남은 시간을 priority(우선도)로 적용한 스케줄링 방식이다. 일반적으로 priority scheduling에서는 priority가 낮은 일이 priority가 높은 일에 비해 우선순위가 밀려서 처리되지 않는 starvation이 발생하는 것이 문제가 된다. 그래서 starvation을 해결하기 위해 다음 기법을 사용한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Aging&lt;/strong&gt;: 프로세스가 오랫동안 기다릴수록 priority를 높인다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 starvation 문제를 해결하더라도 SJF는 어디까지나 ‘이론적인 스케줄러’일 뿐이다.&lt;/p&gt;

&lt;h2 id=&quot;3-round-robin&quot;&gt;3. Round Robin&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;각 일이 정해진 시간 동안만 실행되는 FIFO&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;FIFO지만, 각 일이 특정 시간 동안만 CPU를 점유할 수 있는&lt;/strong&gt; 스케줄링 방식이다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler03.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 3. Round Robin Scheduling
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Figure 3는 time slice가 2로 설정되었을 때 스케줄링이 어떤 방식으로 이루어지는지를 보여준다. SJF와 달리 starvation도 발생하지 않고, FIFO에서 발생하는 convoy effect도 발생하지 않는다. 이렇게 보기에는 쓸만한 스케줄러 같지만, time slice의 크기에 따라 문제가 발생한다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler04.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 4. Too Short Time Slice
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;time slice가 너무 짧아서 FIFO에 비해 response time은 짧지만 나머지 지표가 좋지 않다. Figure 4에서 Round Robin의 모든 프로세스가 FIFO의 모든 프로세스보다 늦거나 같게 끝난다는 것을 확인할 수 있다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler05.png&quot; width=&quot;80%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 5. Too Long Time Slice
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;한편, time slice가 너무 길면 Figure 5와 같이 I/O에 늦게 반응하게 된다. 정리해보면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;task가 대부분 CPU의 처리로 이루어진 CPU-bound task라면 time slice가 길어질수록 효율이 좋다. Figure 4에서 논한 문제는 time slice가 짧아서 발생하였다.&lt;/li&gt;
  &lt;li&gt;task가 대부분 I/O를 기다리는 I/O-bound task라면 time-slice가 짧아야 한다. 만약 time slice가 길다면 입력과 출력에 반응하는 시간이 오래 걸린다. (response time 중시)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본적으로 FIFO이기 때문에 starvation이 발생하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;time slice의 설정 방법에 따라, 그리고 스케줄링되는 task의 속성에 따라 성능이 달라진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;돌아보기&quot;&gt;돌아보기&lt;/h2&gt;

&lt;p&gt;지금까지 FIFO, SJF, Round Robin 스케줄링을 알아보았다. 그 과정에서 각자 발생하는 장점과 단점이 있었는데 이들을 모아서 이상적인 스케줄러의 특성을 나열하면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SJF처럼 짧게 걸리는 일을 빨리 처리해야한다.&lt;/li&gt;
  &lt;li&gt;특정 task가 오랫동안 실행되지 않는 starvation이 발생해서는 안된다.&lt;/li&gt;
  &lt;li&gt;스케줄링을 하는데 걸리는 시간이 오래걸려서는 안된다.&lt;/li&gt;
  &lt;li&gt;CPU-bound task에 대해서 turnaround time을 줄여야 하고, I/O-bound task에 대해서 response time을 줄여야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-multi-level-feedback-queue-mfq&quot;&gt;4. Multi-Level Feedback Queue (MFQ)&lt;/h2&gt;

&lt;p&gt;최종적으로 이 글에서 소개할, 가장 발전된 형태의 uniprocessor 스케줄링 방식이다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler06.png&quot; width=&quot;60%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 6. MFQ Scheduling
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;각자 독립된 priority를 가진 round robin 큐를 만든다. 높은 priority를 가진 큐를 rounb robin 방식으로 스케줄링하고, 종료되지 않은 프로세스를 한 단계 낮은 priority를 가진 큐에 넣는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SJF 처럼 짧게 걸리는 일이 빨리 처리되는가? 예&lt;/p&gt;

    &lt;p&gt;오래 걸리는 일은 round robin 큐를 여러 개 거치면서 priority가 낮아지기 때문에 짧게 걸리는 일이 우선적으로 처리된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;starvation이 발생하지 않는가? 아니오 -&amp;gt; 예(해결 가능)&lt;/p&gt;

    &lt;p&gt;스케줄러가 높은 priority의 큐를 우선적으로 처리하기 때문에 낮은 priority의 큐에 있는 일이 오랫동안 처리되지 않는 starvation이 발생할 우려가 있다. 이 문제는 aging을 이용하면 해결된다. 매번 기다리는 상태에 있는 task를 한 단계 더 높은 priority를 가지는 큐에 넣어주면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스케줄링을 하는데 많은 양의 계산을 요구하지 않는가? 예&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CPU-bound task의 turnaround time이 적은가? 아니요-&amp;gt;예(해결 가능)&lt;/p&gt;

    &lt;p&gt;priority가 낮아질수록 round robin의 time slice를 높이면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I/O-bound task의 reponse가 빠른가? 예&lt;/p&gt;

    &lt;p&gt;만약 많은 양의 CPU의 처리가 요구되는 CPU-bound task가 들어온다면, 여러 큐를 거쳐가면서 priority가 낮아지는 반면, I/O-bound task의 경우 프로세서에서 처리하는 시간이 적어 priority가 잘 낮아지지 않기 때문에 높은 priority에 머무른다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="System" /><category term="scheduler" /><category term="FIFO" /><category term="SJF" /><category term="round robin" /><category term="MFQ" /><summary type="html">사용할 수 있는 CPU는 유한하지만 운영체제는 여러 개의 일task를 한꺼번에 작동시켜야 한다. 그래서 운영체제에서 일이 CPU를 점유하는 시간을 관리해주는 부분이 필요한데, 이를 스케줄러scheduler라고 한다.</summary></entry><entry><title type="html">디렉토리의 구조</title><link href="http://localhost:4000/system/directory/" rel="alternate" type="text/html" title="디렉토리의 구조" /><published>2020-06-18T00:00:00+09:00</published><updated>2020-06-18T00:00:00+09:00</updated><id>http://localhost:4000/system/directory</id><content type="html" xml:base="http://localhost:4000/system/directory/">&lt;p&gt;파일시스템에서 유저가 특정 파일명에서 오프셋 위치에 있는 데이터에 접근하려고 할 때 실제 디스크에 접근하기 위해 일어나는 일은 두 단계로 나뉜다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파일명으로부터 디스크에 저장되어있는 inode를 찾아서 읽는다.&lt;/li&gt;
  &lt;li&gt;inode와 오프셋으로부터 해당 파일에서 오프셋 위치에 있는 블럭의 디스크상의 물리 주소를 구한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/directory/image01.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. inode and inode Array
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;여기서 inode(information node)는 실제 데이터의 포인터와 기타 정보들을 담고 있는 데이터로, 디스크에서 위와 같이 inode array의 형태로 관리된다.&lt;/p&gt;

&lt;p&gt;이 글에서는 1번을 용이하게 만들어주는 &lt;strong&gt;디렉토리&lt;/strong&gt;에 대해서 다루려고 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;디렉토리도 일종의 파일이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;디렉토리도 파일과 크게 다르지 않다. 디렉토리도 그 디렉토리가 포함하는 하위 파일/디렉토리 정보를 디스크에 저장하고, 그 위치를 탐색하기 위해 해당 디렉토리의 inode 또한 디스크에 저장된다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/home/minus21/workspace/app01/main.py&lt;/code&gt;라는 파일에 접근하는 상황을 생각해보자. 루트 디렉토리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt;는 inode 인덱스가 고정되어있기 때문에 inode를 찾아낼 수 있고, 이 inode를 통해 하위 디렉토리들의 이름이 inode 인덱스로 다음과 같이 매핑된다. (이 매핑을 구현하기 위해 다양한 자료구조가 사용될 수 있다)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name | inode index
-----|-------------
bin  | 737
usr  | 924
home | 14
proc | 47
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러면 home의 inode 인덱스 14로부터 inode에 접근할 수 있고, 이 inode가 가리키는 블럭에는 또 같은 형태의 매핑이 존재한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name   | inode index
-------|-------------
minus21| 287
user01 | 894
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 식으로 반복하여 최종적으로 app01 디렉토리의 inode에 접근하고, 이 inode가 가리키는 블럭에 저장된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.py&lt;/code&gt;라는 파일의 inode를 찾아내어 위에 적은 2번 과정을 하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;큰-디렉토리&quot;&gt;큰 디렉토리&lt;/h2&gt;

&lt;p&gt;디스크는 블럭 단위(4KB)로 정보가 관리되는데, 디렉토리의 하위 파일/디렉토리가 아주 많아서 정보가 4KB를 넘어가면 어떻게 될까? 이 범람을 해결하기 위해서는 한 디렉토리를 여러 블럭으로 관리해야 하는데, 디렉토리를 접근하는 다음 두 상황을 모두 고려해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일명(또는 디렉토리명)으로부터 파일에 해당하는 inode를 찾는다.&lt;/li&gt;
  &lt;li&gt;디렉토리 내부의 파일(또는 디렉토리)들을 빠르게 순서대로 탐색할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, 쉽게 말해서 무작위 접근, 순차적 접근 모두 빨라야 한다. 그래서 디렉토리를 구현할 때 B+ 트리와 같은 형태가 사용될 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] 2020 Spring CS330 Operating System Lecture of KAIST&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="System" /><category term="file system" /><category term="directory" /><summary type="html">파일시스템에서 유저가 특정 파일명에서 오프셋 위치에 있는 데이터에 접근하려고 할 때 실제 디스크에 접근하기 위해 일어나는 일은 두 단계로 나뉜다.</summary></entry><entry><title type="html">파일 인덱싱 구조</title><link href="http://localhost:4000/system/file-indexing/" rel="alternate" type="text/html" title="파일 인덱싱 구조" /><published>2020-06-18T00:00:00+09:00</published><updated>2020-06-18T00:00:00+09:00</updated><id>http://localhost:4000/system/file-indexing</id><content type="html" xml:base="http://localhost:4000/system/file-indexing/">&lt;p&gt;운영체제에서 파일시스템은 유저가 파일 이름을 통해서 디스크의 물리적 주소에 저장된 데이터에 접근하는 것을 가능하게 해준다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파일 이름은 각 디렉토리에서 접근하려는 파일의 여러가지 정보를 담고 있는 메타데이터(inode)로 변환되고&lt;/li&gt;
  &lt;li&gt;메타데이터를 통해 필요한 데이터가 저장된 디스크의 블럭을 찾아내어 물리적 주소를 통해 접근한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 글에서는 2번에서 어떤 indexing structure을 통해 어떤 방식으로 메타데이터에 디스크의 블럭 주소들이 저장되는지를 알아볼 것이다. 유저가 사용하는 파일과 디스크에 저장된 데이터에 대해 다음과 같은 특징이 존재한다는 것을 기억하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디스크에 있는 데이터는 블럭 단위로 관리된다.&lt;/li&gt;
  &lt;li&gt;한 파일이 반드시 디스크에서 연속적으로 저장된다는 보장이 없다. fragmentation을 방지하기 위해 높은 확률로 이곳저곳에 쪼개져 있을 것이다.&lt;/li&gt;
  &lt;li&gt;유저가 파일에 접근할 때 파일의 데이터를 연속적으로 읽기도 하고, 랜덤하게 읽기도 한다.&lt;/li&gt;
  &lt;li&gt;파일의 크기는 변할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linked-list&quot;&gt;Linked List&lt;/h2&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/uploads/linkedListAllocation.jpg&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. Linked List File Allocation [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;디스크에 있는 각 블럭이 다음 블럭의 포인터를 저장하고 있다. 파일의 메타데이터는 첫 번째 블럭을 가리킨다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;순차적 접근이 빠르다.&lt;/li&gt;
  &lt;li&gt;구현이 간단하다.&lt;/li&gt;
  &lt;li&gt;쉽게 블럭을 추가하고 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;무작위 접근이 느리다. (크기가 작은 파일의 경우 캐시를 통해 해결 가능하다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메타데이터에는 파일의 첫 번째 블럭 포인터만 저장되기 때문에 임의의 n번째 블럭에 도달하기 위해서 n개의 블럭을 직접 지나야 한다. 따라서 무작위 접근을 할 때 속도가 캐시 메모리에 의존도가 높기 때문에 크기가 작은 파일들을 주로 관리할 때 적합한 파일시스템이다. 실제로 FAT 파일시스템은 파일을 linked list로 관리하는데, USB와 같은 작은 디스크에서 자주 사용된다.&lt;/p&gt;

&lt;h2 id=&quot;array&quot;&gt;Array&lt;/h2&gt;

&lt;p&gt;각 파일의 메타데이터가 모든 블럭 주소를 적어놓은 배열을 가진다. 배열이라는 자료구조의 장점과 단점을 그대로 답습한다.&lt;/p&gt;

&lt;p&gt;장점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구현이 간단하다.&lt;/li&gt;
  &lt;li&gt;순차적 접근, 무작위 접근 모두 빠르다.&lt;/li&gt;
  &lt;li&gt;쉽게 블럭을 추가하고 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;배열의 크기로 파일의 최대 크기가 고정된다&lt;/strong&gt;. 즉, 유동적인 파일 크기 변화가 불가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파일의 최대 크기를 늘리자고 배열의 크기를 모든 파일에 대해서 크게 설정할 수도 없는 노릇이다. 파일시스템으로 사용할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;multi-level-indexing&quot;&gt;Multi-level Indexing&lt;/h2&gt;

&lt;p&gt;배열의 단점을 보완한 방법이다. 해당 방법을 이용하는 파일 시스템으로는 Berkeley UNIX FFS가 있는데, inode에 15개의 블럭 포인터가 저장되어 있다. 이 블럭 포인터들은 디스크에 저장된 다른 블럭 포인터의 주소를 저장할 수도 있고, 바로 물리적 디스크 주소를 저장할 수도 있다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/uploads/Combined-Scheme.jpg&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 2. Multi-level indexing [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;FFS를 기준으로, 첫 번째 12개의 포인터들은 바로 데이터가 담긴 블럭을 가리킨다. 각 블럭이 4KB일 때,  최대 48KB까지 수용할 수 있다.&lt;/p&gt;

&lt;p&gt;13번째 포인터는 indirect 블럭 포인터인다. 이 포인터는 데이터 포인터들을 담고 있는 디스크의 블럭을 가리킨다. 즉, 가리키고 있는 블럭의 크기는 4KB이고, 물리적 주소가 32비트라고 했을 때 이는 4바이트이므로 가리키고 있는 블럭에 최대 1K개의 포인터를 수용할 수 있다. 이 1K개의 포인터는 각각 다른 4KB 짜리 데이터가 저장된 블럭을 가리키므로, 1K와 4KB를 곱해서 최대 4MB의 데이터가 수용 가능하다.&lt;/p&gt;

&lt;p&gt;14번째 포인터는 doubly indirect 블럭 포인터이다. 이 포인터가 가리키고 있는 블럭은 1K의 indirect 블럭을 가리키는데, 각각의 indirect 블럭은 최대 4MB의 데이터가 수용 가능하므로 1K와 4MB를 곱한 4GB의 데이터가 수용 가능하다.&lt;/p&gt;

&lt;p&gt;마지막인 15번째 포인터는 triply indirect 블럭 포인터로, 같은 방식으로 4TB의 데이터가 수용 가능하다.&lt;/p&gt;

&lt;p&gt;이렇게 총 4KB+4MB+4GB+4TB의 데이터를 저장하고 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;장점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;무작위 접근, 순차적 접근 모두 좋다.&lt;/li&gt;
  &lt;li&gt;용량의 제한이 거의 느껴지지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구현이 복잡하다.&lt;/li&gt;
  &lt;li&gt;파일에 접근할 때 디스크에서 여러 번의 indirection을 반복하면 느려진다. (캐시로 보완 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://www.geeksforgeeks.org/file-allocation-methods/&quot;&gt;GeeksforGeeks - File Allocation Methods&lt;/a&gt;&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="System" /><category term="file system" /><summary type="html">운영체제에서 파일시스템은 유저가 파일 이름을 통해서 디스크의 물리적 주소에 저장된 데이터에 접근하는 것을 가능하게 해준다.</summary></entry><entry><title type="html">Substitution-Permuation Network</title><link href="http://localhost:4000/cryptography/SP-network/" rel="alternate" type="text/html" title="Substitution-Permuation Network" /><published>2020-06-17T00:00:00+09:00</published><updated>2020-06-17T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/SP-network</id><content type="html" xml:base="http://localhost:4000/cryptography/SP-network/">&lt;p&gt;DES가 대표적인 Feistel cipher 형태의 블록 암호 알고리즘이었지만 취약한 것으로 알려지면서 미국이 공모전을 통해 새로 제정한 블록 암호 알고리즘이 있는데, 바로 SP-network 형태의 AES이다. (사실 DES도 유사 SP 과정을 Feristel 암호의 round function으로 사용한다)&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/cd/SubstitutionPermutationNetwork2.png&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. 3단계 SP Network 암호 [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;암호화&quot;&gt;암호화&lt;/h2&gt;

&lt;h3 id=&quot;s-box&quot;&gt;S-box&lt;/h3&gt;

&lt;p&gt;S가 치환substitution의 약자인만큼, 입력 비트를 일정한 길이로 쪼개서 그 각각을 &lt;strong&gt;같은 길이&lt;/strong&gt;의 비트로 치환시킨다. 복호화도 가능하게 하기 위해서 &lt;strong&gt;one-to-one&lt;/strong&gt; 관계를 유지해야 한다. Figure 1에서 16비트 평문을 4비트씩 쪼개서 치환시키는 것이 이에 해당한다. S-box는 비선형성이 보장된다.&lt;/p&gt;

&lt;h3 id=&quot;p-box&quot;&gt;P-box&lt;/h3&gt;

&lt;p&gt;P는 비트를 섞는 과정이다. permutation의 약자로, Figure 1에서 P 상자를 자세히 보면 세 번째 비트가 첫 번째 비트가 되고, 14번째 비트가 16번째 비트가 되는 것들을 볼 수 있을 것이다. 이는 입력 비트를 x 벡터, 출력 비트를 y 벡터로 표현했을 때 y=Ax가 되는 행렬 A가 간단하게 존재하므로 선형이다. 또한, 이 비트를 섞는 과정을 역으로 언제나 수행할 수 있고 이는 복호화해서 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;key&quot;&gt;Key&lt;/h3&gt;

&lt;p&gt;매 라운드마다 비밀 키와 XOR시킨다.&lt;/p&gt;

&lt;h2 id=&quot;복호화&quot;&gt;복호화&lt;/h2&gt;

&lt;p&gt;앞에서 서술했듯 S-box와 P-box에 역함수의 존재성이 보장되므로 암호화하는 과정을 역함수를 이용해서 거꾸로 진행하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] Wikipedia - Substitution-permutation network&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Cryptography" /><category term="SP network" /><category term="block cipher" /><summary type="html">DES가 대표적인 Feistel cipher 형태의 블록 암호 알고리즘이었지만 취약한 것으로 알려지면서 미국이 공모전을 통해 새로 제정한 블록 암호 알고리즘이 있는데, 바로 SP-network 형태의 AES이다. (사실 DES도 유사 SP 과정을 Feristel 암호의 round function으로 사용한다)</summary></entry><entry><title type="html">Feistel Cipher</title><link href="http://localhost:4000/cryptography/Feistel-cipher/" rel="alternate" type="text/html" title="Feistel Cipher" /><published>2020-06-15T00:00:00+09:00</published><updated>2020-06-15T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/Feistel-cipher</id><content type="html" xml:base="http://localhost:4000/cryptography/Feistel-cipher/">&lt;p&gt;Feistel 암호는 블록 암호의 일종이다. DES가 대표적이다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/f/fa/Feistel_cipher_diagram_en.svg&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. Feistel 암호의 암호화와 복호화 [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;후술할 암호화와 복호화 과정은 위 그림 하나로 다 설명된다. 암호화할 때 $f$라는 라운드 함수를 사용하는데, 암호화할 때나 복호화할 때나 공통적으로 $f^{-1}$도 아닌 $f$를 그대로 사용한다! 즉, 어떤 형태의 $f$를 제안해도 그것으로 블록 암호를 만들 수 있다는 자유도가 있다. 그리고 암호화하는 과정과 복호화하는 과정이 닮아있기 때문에 시간도 같게 걸린다.&lt;/p&gt;

&lt;h2 id=&quot;암호화&quot;&gt;암호화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;입력: 암호화할 $L_0 \vert\vert R_0$ 블록, 공통적으로 사용할 비밀키 $k_0, \cdots , k_{r-1} $&lt;/li&gt;
  &lt;li&gt;출력: r번의 라운드 함수를 거쳐서 만들어진 $L_r \vert\vert R_r $ 블록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본적이므로 블록 암호이므로 고정된 길이의 입력 $L_0 \vert\vert R_0$을 암호화하는 과정을 살펴볼 것이다. $L_0$와 $R_0$의 길이는 같다.&lt;/p&gt;

&lt;p&gt;r-round Feistel 암호는 이 블록을 매 단계마다 다음과 같이 암호화한다:&lt;/p&gt;

\[(L_{i+1}, R_{i+1}) = (R_i, L_i \oplus f(R_i, k_i)) \quad \text{for } i=0,2,\cdots,r-1\]

&lt;p&gt;여기서 $f$를 라운드 함수round function이라고 부르고, 이 라운드 함수에 사용되는 $k_i$는 i번째 비밀 키이다.&lt;/p&gt;

&lt;p&gt;이렇게 r개의 라운드를 거쳐서 나오는 $R_r \vert\vert L_r$이 암호화된 블록이다.&lt;/p&gt;

&lt;h2 id=&quot;복호화&quot;&gt;복호화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;입력: 복호화할 $L_r \vert\vert R_r$ 블록, 공통적으로 사용할 비밀키  $k_0, \cdots , k_{r-1} $&lt;/li&gt;
  &lt;li&gt;출력: $L_0 \vert\vert R_0$ 평문 블록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;암호화와 똑같은 과정을 뒤집어서 수행한다.&lt;/p&gt;

\[(R_i, L_i) = (L_{i+1},R_{i+1}\oplus f(L_{i+1},k_i)) \quad \text{for } k=0,1,\cdots,r-1\]

&lt;h2 id=&quot;검증&quot;&gt;검증&lt;/h2&gt;

&lt;p&gt;r-round Feistel의 복호화 과정이 정확한 지 확인하고 싶다면, 다음을 확인하면 된다. E와 D는 각각 암호화encrypt와 복호화decrypt를 의미한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$(L_{i+1}, R_{i+1}) = E(L_i, R_i) = (R_i, L_i \oplus f(R_i, k_i))$&lt;/li&gt;
  &lt;li&gt;$(L_i’, R_i’) = D(L_{i+1}, R_{i+1})=(R_{i+1} \oplus f(L_{i+1}, k_i)), L_{i+1} )$&lt;/li&gt;
  &lt;li&gt;$(L_i’,R_i ‘) = (L_i, R_i)$인가?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;먼저, $R_i’ = L_{i+1} = R_i$임은 쉽게 확인된다.&lt;/p&gt;

\[L_i' = R_{i+1} \oplus f(L_{i+1}, k_i) = (L_i \oplus f(R_i,k_i)) \oplus f(L_{i+1}, k_i) = L_i \oplus (f(R_i, k_i) \oplus f(L_{R_i, k_i})) = L_i\]

&lt;p&gt;따라서 각 단계마다 복호화가 유효하다는 것이 확인되었고, 이 단계들로 구성된 r-round Fesistel 암호의 전체 복호화 과정도 정확하다.&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] Wikipedia - Feistel Cipher&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Cryptography" /><category term="Feistel" /><category term="block cipher" /><summary type="html">Feistel 암호는 블록 암호의 일종이다. DES가 대표적이다.</summary></entry><entry><title type="html">PintOS를 짜면서 정리해본 팁과 설정들</title><link href="http://localhost:4000/scribbles/pintos-tips/" rel="alternate" type="text/html" title="PintOS를 짜면서 정리해본 팁과 설정들" /><published>2020-06-15T00:00:00+09:00</published><updated>2020-06-15T00:00:00+09:00</updated><id>http://localhost:4000/scribbles/pintos-tips</id><content type="html" xml:base="http://localhost:4000/scribbles/pintos-tips/">&lt;p&gt;이번 학기에 운영체제 과목의 교육용 운영체제인 PintOS를 짜면서 느낀 점들과 초반 삽질을 줄일만한 팁들을 정리해보았다.&lt;/p&gt;

&lt;p&gt;반드시 꼭 설정해야 할 중요한 알맹이들만 있지는 않고, 프로그래밍을 하다가 지쳤을 때 재미로 설정한 것들도 다수 있다.&lt;/p&gt;

&lt;h2 id=&quot;1-git&quot;&gt;1. Git&lt;/h2&gt;

&lt;p&gt;PintOS는 KAIST에서는 2인 1조로 작업하였고, 협업을 하기 위해서는 &lt;strong&gt;Git을 사용을 안할 수가 없었다&lt;/strong&gt;. 잘 안되서 예전에 짰던 코드로 돌려놓고 싶을 때도 많고, 병렬적으로 팀원과 다른 부분을 구현하여 나중에 합쳐야 하는 경우도 있는데 Git을 사용하면 이 작업들이 쉽게 이루어질 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가장 많이 쓰는 명렁어: git commit, git push, git pull, git status&lt;/li&gt;
  &lt;li&gt;branch 관리 : git checkout, git branch, git merge&lt;/li&gt;
  &lt;li&gt;기타 커밋로그 관리 : git rebase, git reset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Git 저장소로는 대중적인 Github에 비공개 레퍼지토리를 만들어서 관리하였다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/04.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 1. 정말로 화난다면 이런 커밋을 할 수도 있겠지만..&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;나중에 커밋로그를 읽고 팀원이 리뷰를 할 때 힘들어하지 않도록 &lt;a href=&quot;https://meetup.toast.com/posts/106&quot;&gt;좋은 git 커밋 메시지를 작성하기 위한 7가지 약속&lt;/a&gt;을 읽어보고 지키는 것을 추천한다. 내가 요구했던 것은 세 가지였다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기본적인 커밋 메시지 convention을 지키자. 어떤 변화가 있었는지 요약을 담고, 필요에 따라 추가적인 설명을 작성해야 좋은 커밋 메시지이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;커밋을 하기 전에 &lt;strong&gt;최소한 컴파일은 제대로 되는지, 통과했던 테스트케이스가 실패했는지&lt;/strong&gt;를 반드시 확인해주자. 커밋 할 때마다 확인을 하지 않고 한꺼번에 디버깅하면 시간만 많이 잡아먹는다.&lt;/li&gt;
  &lt;li&gt;디버깅을 위해 넣은 printf, ASSERT는 미래에 사용될 일이 없다면 삭제해주자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;브랜치는 큰 변경점이 있거나 새로운 프로젝트를 시작할 때마다 만들어두면 좋다.&lt;/p&gt;

&lt;h2 id=&quot;2-에디터&quot;&gt;2. 에디터&lt;/h2&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/01.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 2. Vim은 정말 좋은 에디터입니다&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;처음에는 습관대로 리눅스 쉘에서 vim을 통해 코드를 관리했지만, 운영체제와 같은 대형 프로젝트를 CLI를 고집하면서 달랑 vim을 통해 관리하는 것에는 현실적인 어려움이 있었다. 소스 파일들, 헤더 파일들, 테스트 코드, 테스트 출력, 컴파일하고 실행시킬 쉘, 디버깅을 할 쉘 등 여러 창을 띄어놓고 해야 하는 만큼 GUI의 직관성과 효율성을 무사하기 힘들다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/02.jfif&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 3. vscode로 관리할 때&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;그래서 Visual Studio Code를 제공된 개발 서버에 원격으로 연결하여 작업했는데 정말 혁명적이었다. 설정은 &lt;a href=&quot;https://code.visualstudio.com/docs/remote/ssh&quot;&gt;Visual Studio Code - Remote Development using SSH&lt;/a&gt;를 참고하였다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl+P&lt;/code&gt;와 같은 몇몇 자주 사용하는 단축키들을 익혀놓으면 효율이 더 올라갈 것이다.&lt;/p&gt;

&lt;h2 id=&quot;3-커뮤니케이션&quot;&gt;3. 커뮤니케이션&lt;/h2&gt;

&lt;p&gt;온라인으로 프로젝트에 대해 이슈를 나누고 서로 피드백해줄 수단이 필요하다. 나는 COVID-19의 영향으로 모든 협업이 온라인으로 진행되었기 때문에 더 의존했던 것 같다. 내 팀은 화면 공유까지 지원하는 Discord를 사용하였다. Slack은 메시지 수 제한도 있고, 화면 공유를 지원하지 않는 것 같아서 선택하지 않았던 것 같다(사실 잘 안써봐서 모른다).&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/03.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 4. Github-Discord webhook&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;또한 Github를 사용한다면 Discord에서 웹훅을 걸 수 있다. 이 작업을 한다면 git push를 할 때마다 디스코드 채널에 자동으로 알림이 가게 된다. 같은 브랜치에서 두 팀원이 작업을 하고 있을 때 git pull을 하지 않아 충돌이 잦았는데, 이렇게 알림을 설정하면 그런 문제를 최소화할 수 있다. 각자 커밋을 할때마다 바로 리뷰를 해줄 수도 있었다. 웹훅을 설정하는 방법은 &lt;a href=&quot;https://gist.github.com/eslachance/40ac1c8232a5a019b43ee3f588d637ad&quot;&gt;Github Gist - Github to Discord Webhook Tutorial&lt;/a&gt;를 참고하라. Slack에도 비슷한 기능이 있던 것으로 기억한다.&lt;/p&gt;

&lt;h2 id=&quot;4-디버깅&quot;&gt;4. 디버깅&lt;/h2&gt;

&lt;p&gt;처음에는 gdb를 사용하지 않고 printf와 ASSERT만을 이용하여 짰는데, 뒤로 갈수록 gdb를 사용하는 것이 필수적이었으며, 앞에서도 gdb를 쓸 줄 알았다면 얼마나 좋았을까 하는 생각이 들었다. 심지어 일부 과정에서는 printf가 프로그램의 흐름을 방해하여 정상적으로 디버깅할 수 없는 경우도 있었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디버깅의 안정성 gdb &amp;gt; ASSERT &amp;gt; printf&lt;/li&gt;
  &lt;li&gt;난이도: gdb « ASSRET = printf&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/gdb.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 5. gdb&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;PintOS를 gdb에 연결하는 작업은 아마 각 프로젝트 메뉴얼에 안내가 되어 있을 것이고, 이 글에서는 자주 사용하는 gdb 명령어만 간략하게 정리해보았다. 더 자세한 내용은 검색을 통해 알아보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; : 소스 코드의 다음 줄을 실행시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt; : 소스 코드의 다음 명령을 실행시킨다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt;는 함수를 한 줄로 간주하여 실행하는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt;은 함수 안에 있는 한 줄을 실행시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p (대상)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x (대상)&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(대상)&lt;/code&gt;은 주소 또는 변수명이 될 수 있다. 그 대상이 갖고 있는 정보를 확인할 때 사용한다. x보다는 p를 자주 사용하는 편. 어떤 방식으로, 어느 만큼 출력할지도 결정할 수 있다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x/30x 주소&lt;/code&gt;는 메모리의 주소~주소+30 까지 정보를 16진수(x)로 출력할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b thread.c:170&lt;/code&gt; : 이것은 한 예로, thread.c의 170번째 줄에 breakpoint를 건다는 뜻이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b 함수명&lt;/code&gt;도 가능하다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d (숫자)&lt;/code&gt; : 숫자에 해당하는 breakpoint를 삭제한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;: 계속 진행시킨다. 다음 breakpoint에 걸리거나 프로그램이 끝날 때까지 실행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기타&quot;&gt;기타&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;내가 수강한 강좌에서는 Q&amp;amp;A를 하기 위한 piazza가 개설되어 있었는데, 여기서 필요한 정보들을 질문하거나 찾는 것이 매우 도움이 되었다. 막히는 부분이 있으면 완전한 문장의 형태로 질문을 정리하는 과정 자체가 좋은 답변과 관계없이 중요하다고 느껴졌다.&lt;/li&gt;
  &lt;li&gt;주어진 메뉴얼을 직접 이해할 때 가장 효율적이고 얻는 것도 많았다. 세세하게 짜는 과정이 나와있는 안내서를 보면 쉽지만 그 안내서에 끌려다니는 느낌이다. 나도 블로그에 PintOS를 짜는 과정을 정리해볼까 하는 생각이 들었지만, 이런 이유로 공유하지 않는게 좋겠다는 생각이 든다.&lt;/li&gt;
  &lt;li&gt;필요할 때마다 그림으로 코드의 흐름을 정리해보는 것이 큰 도움이 되었다. 전체적으로 어떤 과정이 어떻게 돌아가는지를 시각화하여 이해할 수 있고, 불필요한 과정을 잡아내기에도 좋았다.&lt;/li&gt;
  &lt;li&gt;최대한 깨끗하고 완전한, 효율적인 구현을 목표로 하자. 설계를 제대로 하지 않고 무작정 코드를 짜다가 디버깅하면 몸만 고생한다. 특히 자주 사용하는 루틴일수록 더 신경써야 한다. 코딩을 하는 시간을 최소화하고, 설계하고 구상하는 시간을 최대화하자.&lt;/li&gt;
  &lt;li&gt;여럿이서 프로젝트를 진행할 때 협업과 분업이라는 두 가지 선택지가 있다. 즉, 두 명이서 각자 독립된 부분을 완성할지, 힘을 합쳐서 한 부분을 진행할지로 나뉘어진다. 전자는 짧게 보면 고효율을 보이지만 낮은 안정성으로 디버깅에 고생할 것이고, 후자는 저효율을 보이지만 코드를 짤 때마다 즉각적으로 피드백을 받기 때문에 높은 안정성으로 디버깅에 덜 허덕인다. 나는 경험적으로 후자가 더 좋은 선택이라고 본다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Scribbles" /><summary type="html">이번 학기에 운영체제 과목의 교육용 운영체제인 PintOS를 짜면서 느낀 점들과 초반 삽질을 줄일만한 팁들을 정리해보았다.</summary></entry><entry><title type="html">RSA LSB Oracle Attack</title><link href="http://localhost:4000/cryptography/RSA-lsb-oracle-attack/" rel="alternate" type="text/html" title="RSA LSB Oracle Attack" /><published>2020-05-11T00:00:00+09:00</published><updated>2020-05-11T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/RSA-lsb-oracle-attack</id><content type="html" xml:base="http://localhost:4000/cryptography/RSA-lsb-oracle-attack/">&lt;p&gt;암호문을 복호화해서 맨 마지막 비트(least significant bit)를 알려주는 RSA Oracle이 주어졌을 때 적용할 수 있는 공격법이다.&lt;/p&gt;

&lt;h2 id=&quot;어떻게&quot;&gt;어떻게?&lt;/h2&gt;

&lt;p&gt;RSA의 평문(plaintext)을 p, 암호문(ciphertext)을 c라고 놓았을 때, 복호화는 다음과 같이 진행된다:&lt;/p&gt;

\[p \equiv c^d \mod n\]

&lt;p&gt;$c\cdot 2^e$를 같은 방식으로 복호화시켜보자.&lt;/p&gt;

\[(c \cdot 2^e)^d = c^d \cdot 2^{ed} = c^d \cdot 2^{k\phi(n)+1} \equiv 2 c^d \equiv 2p \mod n\]

&lt;p&gt;($2^{k\phi(n)+1} \equiv 2 \mod n$이 되는 부분은 편의를 위해 과감히 생략했다. &lt;a href=&quot;https://3-24.github.io/cryptography/RSA/&quot;&gt;RSA를 설명한 글&lt;/a&gt;의 복호화 증명과 완전히 동일하다.)&lt;/p&gt;

&lt;p&gt;즉, RSA Oracle에 $c \cdot 2^e$를 입력하면 2p를 n으로 나눈 나머지를 계산하고 맨 마지막 비트를 알려준다. 평문은 $n$보다 작다고 가정되므로 두 가지 경우를 고려할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;n &amp;lt; 2p &amp;lt; 2n&lt;br /&gt;
2p를 n으로 나눈 나머지는 2p-n으로, n은 언제나 홀수이기 때문에(짝수이면 n의 두 소수 인수 중 하나는 2로 고정되기 때문에 매우 위험한 RSA이므로 사용되지 않는다!) $2p-n$은 홀수이고, LSB는 1이다.&lt;/li&gt;
  &lt;li&gt;0 &amp;lt; 2p &amp;lt; n&lt;br /&gt;
2p를 n으로 나눈 나머지가 2p이기 떄문에 짝수이므로 LSB가 0이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;똑같은 방식으로 $c \cdot 4^e$를 입력하면 4p를 n으로 나눈 나머지를 계산하고 맨 마지막 비트를 알려준다. 이전 결과에 이어서 총 네 가지 경우로 나눌 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;n &amp;lt; 2p &amp;lt; 2n&lt;br /&gt;
1-1. 3n &amp;lt; 4p &amp;lt; 4n : 4p를 n으로 나눈 나머지는 4p-3n으로, LSB가 1이다.&lt;br /&gt;
1-2. 2n &amp;lt; 4p &amp;lt; 3n : 4p를 n으로 나눈 나머지는 4p-2n으로, LSB가 0이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;0 &amp;lt; 2p &amp;lt; n&lt;br /&gt;
2-1. n &amp;lt; 4p &amp;lt; 2n : 4p를 n으로 나눈 나머지는 4p-n으로, LSB가 1이다.&lt;br /&gt;
2-2. 0 &amp;lt; 4p &amp;lt; n : 4p를 n으로 나눈 나머지는 4p로, LSB가 0이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 두 번의 입력으로 가능한 p의 범위를 1/4로 줄여놓았다. 이런 식으로 계속 반복하여 가능한 p의 범위를 좁혀나가면 평문을 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;공격 예는 &lt;a href=&quot;https://github.com/ashutosh1206/Crypton/blob/master/RSA-encryption/Attack-LSBit-Oracle/README.md&quot;&gt;https://github.com/ashutosh1206/Crypton/blob/master/RSA-encryption/Attack-LSBit-Oracle/README.md&lt;/a&gt; 에 잘 정리되어 있다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Cryptography" /><category term="RSA" /><category term="LSB" /><summary type="html">암호문을 복호화해서 맨 마지막 비트(least significant bit)를 알려주는 RSA Oracle이 주어졌을 때 적용할 수 있는 공격법이다.</summary></entry><entry><title type="html">Length Extension Attack</title><link href="http://localhost:4000/cryptography/length-extension-attack-%EB%B3%B5%EC%82%AC%EB%B3%B8/" rel="alternate" type="text/html" title="Length Extension Attack" /><published>2020-04-04T00:00:00+09:00</published><updated>2020-04-04T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/length-extension-attack%20-%20%EB%B3%B5%EC%82%AC%EB%B3%B8</id><content type="html" xml:base="http://localhost:4000/cryptography/length-extension-attack-%EB%B3%B5%EC%82%AC%EB%B3%B8/">&lt;p&gt;Merkle-Damgard 방식의 해시 함수에 대해 적용할 수 있는 공격법이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;공격자가 모르는 메시지 m1의 해시값과 길이를 알고 있을 때, 공격자가 원하는 임의의 m2를 붙인 메시지 m1 + pad(m1) + m2의 해시값을 알 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;어떻게&quot;&gt;어떻게?&lt;/h2&gt;

&lt;p&gt;비밀 메시지 $m_1$이 패딩을 포함해서 단일 블럭으로 이루어져 있다면,&lt;/p&gt;

\[hash(m_1) = compress(IV, m_1 \vert\vert pad_1 )\]

&lt;p&gt;이 때, 패딩을 포함한 단일 블럭의 메시지 $m_2$에 대하여, $m_3 = m_1 \vert\vert pad_1 \vert\vert m_2$를 고려하고, $Pad(m_3) = m_1 \vert\vert pad_1 \vert\vert m_2 \vert\vert pad_3$로 놓자.&lt;/p&gt;

\[hash(m_3) = compress(compress(IV,m_1 \vert\vert pad_1 ), m_2 \vert\vert pad_3)
\\= compress(hash(m_1),m_2\vert\vert pad_3)\]

&lt;p&gt;이런 식으로 $m_1, m_2$가 단일 블럭이 아니어도, Merkle-Damgard 해시 함수의 특성 상 $hash(m_3)$를 계산할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;예를 들어, 메시지의 인증을 확인하기 위해 MAC(Message Authentication Code)로 다음과 같은 함수를 사용한다고 하자:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;secret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;SECRET!&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# message의 해시 값을 계산
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create_mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashlib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;md5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexdigest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 유저가 보낸 message의 mac 시그니처가 해시값과 일치하는지 확인
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;check_auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usermac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usermac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;어떤 웹사이트에 PHP 리퀘스트를 GET 방식으로 데이터와 시그니처를 다음과 같이 보낼 수 있다고 하자:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user_id=1323&amp;amp;size=large&amp;amp;count=1&amp;amp;flavor=choco
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sign=8ccb1040d76a517033265be77f7b8506
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 때 시그니처의 길이가 32이기 때문에, 16진수 하나당 4비트이므로 128비트이고, 128비트의 출력을 하는 자주 쓰이는 암호학적 해시 함수는 MD5 정도라고 추측할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 공격자가 하고 싶은 것은 flavor를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mintchoco&lt;/code&gt;로 덮는것이라고 하자.&lt;/p&gt;

&lt;p&gt;length extension attack을 적용할 때 문제는 secret의 길이를 모른다는 부분인다. 그냥 짧을 것이라고 추측해서 직접 패딩을 일일이 만들어서 직접 MD5 해시를 계산해서 인증을 시도해보고, 맞으면 secret의 길이가 7임을 알 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 m1의 길이는 51이고 한 글자는 1바이트=8비트이므로, 총 408비트이고, MD5에서 패딩을 만드는 방식에 의하면 pad1은 다음과 같이 형성된다:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1000 0000 0000 0000 0000 0000 0000 0000
0000 0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10...0&lt;/code&gt;을 448비트가 될 때까지 채우고&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1000 1001 0001 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;408비트는 이진수로 110011000이므로 little-endian으로 채웠을 때 (총 64비트)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이걸 다 붙여서&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user_id=1323&amp;amp;size=large&amp;amp;count=1&amp;amp;flavor=choco\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00&amp;amp;flavor=mintchoco
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로 덮는다. 이 때 인증키 sign은&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;compress(8ccb1040d76a517033265be77f7b8506, &quot;&amp;amp;flavor=mintchoco&quot; + pad3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 계산해서 얻을 수 있다. 이제 pad3를 계산하고 compress를 md5 algorithm에서 가져와야 하는데..&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그냥 다른 사람이 만들어놓은 툴을 쓰자(&lt;a href=&quot;https://github.com/iagox86/hash_extender&quot;&gt;hash_extender&lt;/a&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;직접 하길 원한다면 hash_extender의 README를 읽어보는 것도 괜찮다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./hash_extender -d &quot;user_id=1323&amp;amp;size=large&amp;amp;count=1&amp;amp;flavor=choco&quot; -l 7 -a &quot;&amp;amp;flavor=mintchoco&quot; -s 8ccb1040d76a517033265be77f7b8506 -f md5
Type: md5
Secret length: 7
New signature: aed5d57ec6cb8c79b245d864665b3193
New string: 757365725f69643d313332332673697a653d6c6172676526636f756e743d3126666c61766f723d63686f636f8000000000980100000000000026666c61766f723d6d696e7463686f636f

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로 얻은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sign=aed5d57ec6cb8c79b245d864665b3193&lt;/code&gt;이 이제 있다.&lt;/p&gt;

&lt;p&gt;New string을 bytearray로 바꿔서 출력해보면 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# s는 아까 얻은 New String
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;barr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bytearray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromhex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;barr&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;bytearray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;b'user_id=1323&amp;amp;size=large&amp;amp;count=1&amp;amp;flavor=choco&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;amp;flavor=mintchoco'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(위에서 직접 손으로 패딩을 계산했던 것이 일치함을 확인할 수 있다!) 어쩄든 결과로 인증을 시도해보자.&lt;/p&gt;

&lt;p&gt;직접 secret을 붙여서 인증 서버 쪽에서 md5를 계산하면 다음과 같을 것이다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;hashlib&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashlib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;md5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;b'SECRET!'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;barr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexdigest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;'aed5d57ec6cb8c79b245d864665b3193'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해시 값이 위에서 얻은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sign&lt;/code&gt;과 동일하다!&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Cryptography" /><category term="hash function" /><category term="Merkle-Damgard" /><category term="MD5" /><summary type="html">Merkle-Damgard 방식의 해시 함수에 대해 적용할 수 있는 공격법이다.</summary></entry><entry><title type="html">Merkle-Damgard 해시 함수</title><link href="http://localhost:4000/cryptography/Merkle-Damgard/" rel="alternate" type="text/html" title="Merkle-Damgard 해시 함수" /><published>2020-04-03T00:00:00+09:00</published><updated>2020-04-03T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/Merkle-Damgard</id><content type="html" xml:base="http://localhost:4000/cryptography/Merkle-Damgard/">&lt;blockquote&gt;
  &lt;p&gt;collision-resistant한 해시 함수를 만드는 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MD5(!), SHA1, SHA2 등에 적용된다. (아쉽게도, MD5의 MD는 Message Digest의 약자라고 한다) 그림으로 표현하면 다음과 같다. IV에 메시지 블록1을 압축시키고, 그 출력에 메시지 블록2를 압축시키고 … 이를 반복하여 마지막 메시지 블록을 통과시킨다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Merkle-Damgard_hash_big.svg/1920px-Merkle-Damgard_hash_big.svg.png&quot; /&gt;
    &lt;figcaption&gt; Figure 1. MD construction의 구조 &lt;/figcaption&gt;
&lt;/div&gt;

&lt;h2 id=&quot;compression-function&quot;&gt;Compression Function&lt;/h2&gt;

&lt;p&gt;compression 함수 $f$를 가정한다. compression 함수라 함은 다음을 의미한다:&lt;/p&gt;

\[f:\{0,1\}^m \times \{0,1\}^n \to \{0,1\}^m\]

&lt;p&gt;즉, m비트와 n비트의 입력을 받아 m비트로 대응시킨다.&lt;/p&gt;

&lt;p&gt;단, 이 $f$는 출력으로부터 두 입력을 아는 것이 어려워야 하며(단방향, one-way) $f(m_1)=f(m_2)$인 서로 다른 $m_1, m_2$를 아는 것도 어려워야 한다(collision-resistant).&lt;/p&gt;

&lt;h2 id=&quot;initialization-vector&quot;&gt;Initialization Vector&lt;/h2&gt;

&lt;p&gt;처음 compression 함수에 들어가는 m비트는 IV이다.&lt;/p&gt;

&lt;h2 id=&quot;merkle-damgard-compliant-padding&quot;&gt;Merkle-Damgard Compliant Padding&lt;/h2&gt;

&lt;p&gt;메시지를 n비트 블록 단위로 쪼개어서 compression 함수에 넣기 때문에 메시지의 길이가 n비트의 단위가 아닐 경우 이를 n비트로 강제로 만드는 과정이 필요하다.&lt;/p&gt;

\[Pad : \{0,1\}^* \to \{0,1\}^{n} \cup \{0,1\}^{2n} \cup \cdots\]

&lt;p&gt;MD construction의 안전성을 보장하기 위해 이 패딩함수 $Pad$에는 메시지 $M$에 대해 다음과 같은 충분조건이 존재한다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$Pad(M)$은 $M$으로 시작해야한다.&lt;/li&gt;
  &lt;li&gt;$\lvert M_1\rvert = \lvert M_2 \rvert \implies \lvert Pad(M_1) \rvert = \lvert Pad(M_2) \rvert $&lt;/li&gt;
  &lt;li&gt;$\lvert M_1\rvert  \ne \lvert M_2\rvert  \implies Pad(M_1) $의 마지막 블록 $\ne Pad(M_2)$의 마지막 블록&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;md5의-예시&quot;&gt;MD5의 예시&lt;/h2&gt;

&lt;p&gt;Merkle-Damgard construction이라는 것을 확인하기 위해 알고리즘을 다소 생략했다. 전문(&lt;a href=&quot;https://en.wikipedia.org/wiki/MD5#Pseudocode&quot;&gt;#&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Note: All variables are unsigned 32 bit and wrap modulo 2^32 when calculating
var int s[64], K[64] // predefined arrays
var int i

// Initialize variables:
var int a0 := 0x67452301   // A
var int b0 := 0xefcdab89   // B
var int c0 := 0x98badcfe   // C
var int d0 := 0x10325476   // D

// Padding 추가
append &quot;1&quot; bit to message    
// Notice: the input bytes are considered as bits strings,
//  where the first bit is the most significant bit of the byte.[50]
append &quot;0&quot; bit until message length in bits ≡ 448 (mod 512)
append original length in bits mod 2^64 to message

// Process the message in successive 512-bit chunks:
for each 512-bit chunk of padded message do
    break chunk into sixteen 32-bit words M[j], 0 ≤ j ≤ 15
    // Initialize hash value for this chunk:
    var int A := a0
    var int B := b0
    var int C := c0
    var int D := d0
    // Main loop:
    for i from 0 to 63 do
        var int F, g
        if 0 ≤ i ≤ 15 then
            F := (B and C) or ((not B) and D)
            g := i
        else if 16 ≤ i ≤ 31 then
            F := (D and B) or ((not D) and C)
            g := (5×i + 1) mod 16
        else if 32 ≤ i ≤ 47 then
            F := B xor C xor D
            g := (3×i + 5) mod 16
        else if 48 ≤ i ≤ 63 then
            F := C xor (B or (not D))
            g := (7×i) mod 16
        // Be wary of the below definitions of a,b,c,d
        F := F + A + K[i] + M[g]  // M[g] must be a 32-bits block
        A := D
        D := C
        C := B
        B := B + leftrotate(F, s[i])
    end for
    // Add this chunk's hash to result so far:
    a0 := a0 + A
    b0 := b0 + B
    c0 := c0 + C
    d0 := d0 + D
end for

var char digest[16] := a0 append b0 append c0 append d0 // (Output is in little-endian)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;따라서 MD5 Merkle-Damgard 해시 함수이다. 여기서 사용한 패딩은 다른 SHA1, SHA2와도 공유하는 방법으로, 과정은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;메시지 끝에 1을 붙인다.&lt;/li&gt;
  &lt;li&gt;그 뒤에 비트 mod 512로 448이 될 때까지 0을 붙인다. 그러면 이제 채워야 할 64비트가 남는다.&lt;/li&gt;
  &lt;li&gt;$\lvert M \rvert $를 mod $2^{64}$한 값을 little-endian 64비트 정수가 되도록 채운다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 들어, 메시지가 400비트였다면, 448비트가 될 때까지&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 붙이고&lt;/p&gt;

&lt;p&gt;400비트는 이진수로 110010000이기 때문에 little-endian은 하위 바이트가 낮은 주소로 들어와야 하므로,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0000 1001 0001 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 붙여야 한다. 즉, 4000비트 메시지의 패딩은&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 1001 0001 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 byte-array로 바꾼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\x80\x00\x00\x00\x00\x00\x09\x10\x00\x00\x00\x00\x00\x00&lt;/code&gt;이다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Cryptography" /><category term="hash function" /><category term="Merkle-Damgard" /><summary type="html">collision-resistant한 해시 함수를 만드는 방법</summary></entry></feed>