<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-06-18T23:18:41+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Three Dash Two Four</title><subtitle>수학과 개발을 오가며</subtitle><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><entry><title type="html">File Indexing Structure</title><link href="http://localhost:4000/stystem/file-indexing/" rel="alternate" type="text/html" title="File Indexing Structure" /><published>2020-06-18T00:00:00+09:00</published><updated>2020-06-18T00:00:00+09:00</updated><id>http://localhost:4000/stystem/file-indexing</id><content type="html" xml:base="http://localhost:4000/stystem/file-indexing/">&lt;p&gt;운영체제에서 파일시스템은 유저가 파일 이름을 통해서 디스크의 물리적 주소에 저장된 데이터에 접근하는 것을 가능하게 해준다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파일 이름은 각 디렉토리에서 접근하려는 파일의 여러가지 정보를 담고 있는 메타데이터(inode)로 변환되고&lt;/li&gt;
  &lt;li&gt;메타데이터를 통해 필요한 데이터가 저장된 디스크의 블럭을 찾아내어 물리적 주소를 통해 접근한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 글에서는 2번에서 어떤 indexing structure을 통해 어떤 방식으로 메타데이터에 디스크의 블럭 주소들이 저장되는지를 알아볼 것이다. 유저가 사용하는 파일과 디스크에 저장된 데이터에 대해 다음과 같은 특징이 존재한다는 것을 기억하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디스크에 있는 데이터는 블럭 단위로 관리된다.&lt;/li&gt;
  &lt;li&gt;한 파일이 반드시 디스크에서 연속적으로 저장된다는 보장이 없다. fragmentation을 방지하기 위해 높은 확률로 이곳저곳에 쪼개져 있을 것이다.&lt;/li&gt;
  &lt;li&gt;유저가 파일에 접근할 때 파일의 데이터를 연속적으로 읽기도 하고, 랜덤하게 읽기도 한다.&lt;/li&gt;
  &lt;li&gt;파일의 크기는 변할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linked-list&quot;&gt;Linked List&lt;/h2&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/uploads/linkedListAllocation.jpg&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. Linked List File Allocation [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;디스크에 있는 각 블럭이 다음 블럭의 포인터를 저장하고 있다. 파일의 메타데이터는 첫 번째 블럭을 가리킨다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;순차적 접근이 빠르다.&lt;/li&gt;
  &lt;li&gt;구현이 간단하다.&lt;/li&gt;
  &lt;li&gt;쉽게 블럭을 추가하고 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;무작위 접근이 느리다. (크기가 작은 파일의 경우 캐시를 통해 해결 가능하다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메타데이터에는 파일의 첫 번째 블럭 포인터만 저장되기 때문에 임의의 n번째 블럭에 도달하기 위해서 n개의 블럭을 직접 지나야 한다. 따라서 무작위 접근을 할 때 속도가 캐시 메모리에 의존도가 높기 때문에 크기가 작은 파일들을 주로 관리할 때 적합한 파일시스템이다. 실제로 FAT 파일시스템은 파일을 linked list로 관리하는데, USB와 같은 작은 디스크에서 자주 사용된다.&lt;/p&gt;

&lt;h2 id=&quot;array&quot;&gt;Array&lt;/h2&gt;

&lt;p&gt;각 파일의 메타데이터가 모든 블럭 주소를 적어놓은 배열을 가진다. 배열이라는 자료구조의 장점과 단점을 그대로 답습한다.&lt;/p&gt;

&lt;p&gt;장점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구현이 간단하다.&lt;/li&gt;
  &lt;li&gt;순차적 접근, 무작위 접근 모두 빠르다.&lt;/li&gt;
  &lt;li&gt;쉽게 블럭을 추가하고 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;배열의 크기로 파일의 최대 크기가 고정된다&lt;/strong&gt;. 즉, 유동적인 파일 크기 변화가 불가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파일의 최대 크기를 늘리자고 배열의 크기를 모든 파일에 대해서 크게 설정할 수도 없는 노릇이다. 파일시스템으로 사용할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;multi-level-indexing&quot;&gt;Multi-level Indexing&lt;/h2&gt;

&lt;p&gt;배열의 단점을 보완한 방법이다. 해당 방법을 이용하는 파일 시스템으로는 Berkeley UNIX FFS가 있는데, inode에 15개의 블럭 포인터가 저장되어 있다. 이 블럭 포인터들은 디스크에 저장된 다른 블럭 포인터의 주소를 저장할 수도 있고, 바로 물리적 디스크 주소를 저장할 수도 있다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/uploads/Combined-Scheme.jpg&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 2. Multi-level indexing [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;FFS를 기준으로, 첫 번째 12개의 포인터들은 바로 데이터가 담긴 블럭을 가리킨다. 각 블럭이 4KB일 때,  최대 48KB까지 수용할 수 있다.&lt;/p&gt;

&lt;p&gt;13번째 포인터는 indirect 블럭 포인터인다. 이 포인터는 데이터 포인터들을 담고 있는 디스크의 블럭을 가리킨다. 즉, 가리키고 있는 블럭의 크기는 4KB이고, 물리적 주소가 32비트라고 했을 때 이는 4바이트이므로 가리키고 있는 블럭에 최대 1K개의 포인터를 수용할 수 있다. 이 1K개의 포인터는 각각 다른 4KB 짜리 데이터가 저장된 블럭을 가리키므로, 1K와 4KB를 곱해서 최대 4MB의 데이터가 수용 가능하다.&lt;/p&gt;

&lt;p&gt;14번째 포인터는 doubly indirect 블럭 포인터이다. 이 포인터가 가리키고 있는 블럭은 1K의 indirect 블럭을 가리키는데, 각각의 indirect 블럭은 최대 4MB의 데이터가 수용 가능하므로 1K와 4MB를 곱한 4GB의 데이터가 수용 가능하다.&lt;/p&gt;

&lt;p&gt;마지막인 15번째 포인터는 triply indirect 블럭 포인터로, 같은 방식으로 4TB의 데이터가 수용 가능하다.&lt;/p&gt;

&lt;p&gt;이렇게 총 4KB+4MB+4GB+4TB의 데이터를 저장하고 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;장점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;무작위 접근, 순차적 접근 모두 좋다.&lt;/li&gt;
  &lt;li&gt;용량의 제한이 거의 느껴지지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구현이 복잡하다.&lt;/li&gt;
  &lt;li&gt;파일에 접근할 때 디스크에서 여러 번의 indirection을 반복하면 느려진다. (캐시로 보완 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://www.geeksforgeeks.org/file-allocation-methods/&quot;&gt;GeeksforGeeks - File Allocation Methods&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] 2020 Spring CS330 Operating System Lecture of KAIST&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="file system" /><summary type="html">운영체제에서 파일시스템은 유저가 파일 이름을 통해서 디스크의 물리적 주소에 저장된 데이터에 접근하는 것을 가능하게 해준다.</summary></entry><entry><title type="html">Substitution-Permuation Network</title><link href="http://localhost:4000/cryptography/SP-network/" rel="alternate" type="text/html" title="Substitution-Permuation Network" /><published>2020-06-17T00:00:00+09:00</published><updated>2020-06-17T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/SP-network</id><content type="html" xml:base="http://localhost:4000/cryptography/SP-network/">&lt;p&gt;DES가 대표적인 Feistel cipher 형태의 블록 암호 알고리즘이었지만 취약한 것으로 알려지면서 미국이 공모전을 통해 새로 제정한 블록 암호 알고리즘이 있는데, 바로 SP-network 형태의 AES이다. (사실 DES도 유사 SP 과정을 Feristel 암호의 round function으로 사용한다)&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/cd/SubstitutionPermutationNetwork2.png&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. 3단계 SP Network 암호 [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;암호화&quot;&gt;암호화&lt;/h2&gt;

&lt;h3 id=&quot;s-box&quot;&gt;S-box&lt;/h3&gt;

&lt;p&gt;S가 치환substitution의 약자인만큼, 입력 비트를 일정한 길이로 쪼개서 그 각각을 &lt;strong&gt;같은 길이&lt;/strong&gt;의 비트로 치환시킨다. 복호화도 가능하게 하기 위해서 &lt;strong&gt;one-to-one&lt;/strong&gt; 관계를 유지해야 한다. Figure 1에서 16비트 평문을 4비트씩 쪼개서 치환시키는 것이 이에 해당한다. S-box는 비선형성이 보장된다.&lt;/p&gt;

&lt;h3 id=&quot;p-box&quot;&gt;P-box&lt;/h3&gt;

&lt;p&gt;P는 비트를 섞는 과정이다. permutation의 약자로, Figure 1에서 P 상자를 자세히 보면 세 번째 비트가 첫 번째 비트가 되고, 14번째 비트가 16번째 비트가 되는 것들을 볼 수 있을 것이다. 이는 입력 비트를 x 벡터, 출력 비트를 y 벡터로 표현했을 때 y=Ax가 되는 행렬 A가 간단하게 존재하므로 선형이다. 또한, 이 비트를 섞는 과정을 역으로 언제나 수행할 수 있고 이는 복호화해서 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;key&quot;&gt;Key&lt;/h3&gt;

&lt;p&gt;매 라운드마다 비밀 키와 XOR시킨다.&lt;/p&gt;

&lt;h2 id=&quot;복호화&quot;&gt;복호화&lt;/h2&gt;

&lt;p&gt;앞에서 서술했듯 S-box와 P-box에 역함수의 존재성이 보장되므로 암호화하는 과정을 역함수를 이용해서 거꾸로 진행하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] Wikipedia - Substitution-permutation network&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="SP network" /><category term="block cipher" /><summary type="html">DES가 대표적인 Feistel cipher 형태의 블록 암호 알고리즘이었지만 취약한 것으로 알려지면서 미국이 공모전을 통해 새로 제정한 블록 암호 알고리즘이 있는데, 바로 SP-network 형태의 AES이다. (사실 DES도 유사 SP 과정을 Feristel 암호의 round function으로 사용한다)</summary></entry><entry><title type="html">Feistel Cipher</title><link href="http://localhost:4000/cryptography/Feistel-cipher/" rel="alternate" type="text/html" title="Feistel Cipher" /><published>2020-06-15T00:00:00+09:00</published><updated>2020-06-15T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/Feistel-cipher</id><content type="html" xml:base="http://localhost:4000/cryptography/Feistel-cipher/">&lt;p&gt;Feistel 암호는 블록 암호의 일종이다. DES가 대표적이다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/f/fa/Feistel_cipher_diagram_en.svg&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. Feistel 암호의 암호화와 복호화 [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;후술할 암호화와 복호화 과정은 위 그림 하나로 다 설명된다. 암호화할 때 $f$라는 라운드 함수를 사용하는데, 암호화할 때나 복호화할 때나 공통적으로 $f^{-1}$도 아닌 $f$를 그대로 사용한다! 즉, 어떤 형태의 $f$를 제안해도 그것으로 블록 암호를 만들 수 있다는 자유도가 있다. 그리고 암호화하는 과정과 복호화하는 과정이 닮아있기 때문에 시간도 같게 걸린다.&lt;/p&gt;

&lt;h2 id=&quot;암호화&quot;&gt;암호화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;입력: 암호화할 $L_0 \vert\vert R_0$ 블록, 공통적으로 사용할 비밀키 $k_0, \cdots , k_{r-1} $&lt;/li&gt;
  &lt;li&gt;출력: r번의 라운드 함수를 거쳐서 만들어진 $L_r \vert\vert R_r $ 블록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본적이므로 블록 암호이므로 고정된 길이의 입력 $L_0 \vert\vert R_0$을 암호화하는 과정을 살펴볼 것이다. $L_0$와 $R_0$의 길이는 같다.&lt;/p&gt;

&lt;p&gt;r-round Feistel 암호는 이 블록을 매 단계마다 다음과 같이 암호화한다:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(L_{i+1}, R_{i+1}) = (R_i, L_i \oplus f(R_i, k_i)) \quad \text{for } i=0,2,\cdots,r-1&lt;/script&gt;

&lt;p&gt;여기서 $f$를 라운드 함수round function이라고 부르고, 이 라운드 함수에 사용되는 $k_i$는 i번째 비밀 키이다.&lt;/p&gt;

&lt;p&gt;이렇게 r개의 라운드를 거쳐서 나오는 $R_r \vert\vert L_r$이 암호화된 블록이다.&lt;/p&gt;

&lt;h2 id=&quot;복호화&quot;&gt;복호화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;입력: 복호화할 $L_r \vert\vert R_r$ 블록, 공통적으로 사용할 비밀키  $k_0, \cdots , k_{r-1} $&lt;/li&gt;
  &lt;li&gt;출력: $L_0 \vert\vert R_0$ 평문 블록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;암호화와 똑같은 과정을 뒤집어서 수행한다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(R_i, L_i) = (L_{i+1},R_{i+1}\oplus f(L_{i+1},k_i)) \quad \text{for } k=0,1,\cdots,r-1&lt;/script&gt;

&lt;h2 id=&quot;검증&quot;&gt;검증&lt;/h2&gt;

&lt;p&gt;r-round Feistel의 복호화 과정이 정확한 지 확인하고 싶다면, 다음을 확인하면 된다. E와 D는 각각 암호화encrypt와 복호화decrypt를 의미한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$(L_{i+1}, R_{i+1}) = E(L_i, R_i) = (R_i, L_i \oplus f(R_i, k_i))$&lt;/li&gt;
  &lt;li&gt;$(L_i’, R_i’) = D(L_{i+1}, R_{i+1})=(R_{i+1} \oplus f(L_{i+1}, k_i)), L_{i+1} )$&lt;/li&gt;
  &lt;li&gt;$(L_i’,R_i ‘) = (L_i, R_i)$인가?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;먼저, $R_i’ = L_{i+1} = R_i$임은 쉽게 확인된다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L_i' = R_{i+1} \oplus f(L_{i+1}, k_i) = (L_i \oplus f(R_i,k_i)) \oplus f(L_{i+1}, k_i) = L_i \oplus (f(R_i, k_i) \oplus f(L_{R_i, k_i})) = L_i&lt;/script&gt;

&lt;p&gt;따라서 각 단계마다 복호화가 유효하다는 것이 확인되었고, 이 단계들로 구성된 r-round Fesistel 암호의 전체 복호화 과정도 정확하다.&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] Wikipedia - Feistel Cipher&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Feistel" /><category term="block cipher" /><summary type="html">Feistel 암호는 블록 암호의 일종이다. DES가 대표적이다.</summary></entry><entry><title type="html">PintOS를 짜면서 정리해본 팁과 설정들</title><link href="http://localhost:4000/scribbles/pintos-tips/" rel="alternate" type="text/html" title="PintOS를 짜면서 정리해본 팁과 설정들" /><published>2020-06-15T00:00:00+09:00</published><updated>2020-06-15T00:00:00+09:00</updated><id>http://localhost:4000/scribbles/pintos-tips</id><content type="html" xml:base="http://localhost:4000/scribbles/pintos-tips/">&lt;p&gt;이번 학기에 운영체제 과목의 교육용 운영체제인 PintOS를 짜면서 느낀 점들과 초반 삽질을 줄일만한 팁들을 정리해보았다.&lt;/p&gt;

&lt;p&gt;반드시 꼭 설정해야 할 중요한 알맹이들만 있지는 않고, 프로그래밍을 하다가 지쳤을 때 재미로 설정한 것들도 다수 있다.&lt;/p&gt;

&lt;h2 id=&quot;1-git&quot;&gt;1. Git&lt;/h2&gt;

&lt;p&gt;PintOS는 KAIST에서는 2인 1조로 작업하였고, 협업을 하기 위해서는 &lt;strong&gt;Git을 사용을 안할 수가 없었다&lt;/strong&gt;. 잘 안되서 예전에 짰던 코드로 돌려놓고 싶을 때도 많고, 병렬적으로 팀원과 다른 부분을 구현하여 나중에 합쳐야 하는 경우도 있는데 Git을 사용하면 이 작업들이 쉽게 이루어질 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가장 많이 쓰는 명렁어: git commit, git push, git pull, git status&lt;/li&gt;
  &lt;li&gt;branch 관리 : git checkout, git branch, git merge&lt;/li&gt;
  &lt;li&gt;기타 커밋로그 관리 : git rebase, git reset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Git 저장소로는 대중적인 Github에 비공개 레퍼지토리를 만들어서 관리하였다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/04.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 1. 정말로 화난다면 이런 커밋을 할 수도 있겠지만..&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;나중에 커밋로그를 읽고 팀원이 리뷰를 할 때 힘들어하지 않도록 &lt;a href=&quot;https://meetup.toast.com/posts/106&quot;&gt;좋은 git 커밋 메시지를 작성하기 위한 7가지 약속&lt;/a&gt;을 읽어보고 지키는 것을 추천한다. 내가 요구했던 것은 세 가지였다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기본적인 커밋 메시지 convention을 지키자. 어떤 변화가 있었는지 요약을 담고, 필요에 따라 추가적인 설명을 작성해야 좋은 커밋 메시지이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;커밋을 하기 전에 &lt;strong&gt;최소한 컴파일은 제대로 되는지, 통과했던 테스트케이스가 실패했는지&lt;/strong&gt;를 반드시 확인해주자. 커밋 할 때마다 확인을 하지 않고 한꺼번에 디버깅하면 시간만 많이 잡아먹는다.&lt;/li&gt;
  &lt;li&gt;디버깅을 위해 넣은 printf, ASSERT는 미래에 사용될 일이 없다면 삭제해주자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;브랜치는 큰 변경점이 있거나 새로운 프로젝트를 시작할 때마다 만들어두면 좋다.&lt;/p&gt;

&lt;h2 id=&quot;2-에디터&quot;&gt;2. 에디터&lt;/h2&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/01.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 2. Vim은 정말 좋은 에디터입니다&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;처음에는 습관대로 리눅스 쉘에서 vim을 통해 코드를 관리했지만, 운영체제와 같은 대형 프로젝트를 CLI를 고집하면서 달랑 vim을 통해 관리하는 것에는 현실적인 어려움이 있었다. 소스 파일들, 헤더 파일들, 테스트 코드, 테스트 출력, 컴파일하고 실행시킬 쉘, 디버깅을 할 쉘 등 여러 창을 띄어놓고 해야 하는 만큼 GUI의 직관성과 효율성을 무사하기 힘들다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/02.jfif&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 3. vscode로 관리할 때&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;그래서 Visual Studio Code를 제공된 개발 서버에 원격으로 연결하여 작업했는데 정말 혁명적이었다. 설정은 &lt;a href=&quot;https://code.visualstudio.com/docs/remote/ssh&quot;&gt;Visual Studio Code - Remote Development using SSH&lt;/a&gt;를 참고하였다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+P&lt;/code&gt;와 같은 몇몇 자주 사용하는 단축키들을 익혀놓으면 효율이 더 올라갈 것이다.&lt;/p&gt;

&lt;h2 id=&quot;3-커뮤니케이션&quot;&gt;3. 커뮤니케이션&lt;/h2&gt;

&lt;p&gt;온라인으로 프로젝트에 대해 이슈를 나누고 서로 피드백해줄 수단이 필요하다. 나는 COVID-19의 영향으로 모든 협업이 온라인으로 진행되었기 때문에 더 의존했던 것 같다. 내 팀은 화면 공유까지 지원하는 Discord를 사용하였다. Slack은 메시지 수 제한도 있고, 화면 공유를 지원하지 않는 것 같아서 선택하지 않았던 것 같다(사실 잘 안써봐서 모른다).&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/03.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 4. Github-Discord webhook&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;또한 Github를 사용한다면 Discord에서 웹훅을 걸 수 있다. 이 작업을 한다면 git push를 할 때마다 디스코드 채널에 자동으로 알림이 가게 된다. 같은 브랜치에서 두 팀원이 작업을 하고 있을 때 git pull을 하지 않아 충돌이 잦았는데, 이렇게 알림을 설정하면 그런 문제를 최소화할 수 있다. 각자 커밋을 할때마다 바로 리뷰를 해줄 수도 있었다. 웹훅을 설정하는 방법은 &lt;a href=&quot;https://gist.github.com/eslachance/40ac1c8232a5a019b43ee3f588d637ad&quot;&gt;Github Gist - Github to Discord Webhook Tutorial&lt;/a&gt;를 참고하라. Slack에도 비슷한 기능이 있던 것으로 기억한다.&lt;/p&gt;

&lt;h2 id=&quot;4-디버깅&quot;&gt;4. 디버깅&lt;/h2&gt;

&lt;p&gt;처음에는 gdb를 사용하지 않고 printf와 ASSERT만을 이용하여 짰는데, 뒤로 갈수록 gdb를 사용하는 것이 필수적이었으며, 앞에서도 gdb를 쓸 줄 알았다면 얼마나 좋았을까 하는 생각이 들었다. 심지어 일부 과정에서는 printf가 프로그램의 흐름을 방해하여 정상적으로 디버깅할 수 없는 경우도 있었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디버깅의 안정성 gdb &amp;gt; ASSERT &amp;gt; printf&lt;/li&gt;
  &lt;li&gt;난이도: gdb « ASSRET = printf&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/gdb.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 5. gdb&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;PintOS를 gdb에 연결하는 작업은 아마 각 프로젝트 메뉴얼에 안내가 되어 있을 것이고, 이 글에서는 자주 사용하는 gdb 명령어만 간략하게 정리해보았다. 더 자세한 내용은 검색을 통해 알아보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; : 소스 코드의 다음 줄을 실행시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;step&lt;/code&gt; : 소스 코드의 다음 명령을 실행시킨다. &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;는 함수를 한 줄로 간주하여 실행하는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;step&lt;/code&gt;은 함수 안에 있는 한 줄을 실행시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;p (대상)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x (대상)&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;(대상)&lt;/code&gt;은 주소 또는 변수명이 될 수 있다. 그 대상이 갖고 있는 정보를 확인할 때 사용한다. x보다는 p를 자주 사용하는 편. 어떤 방식으로, 어느 만큼 출력할지도 결정할 수 있다. 예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;x/30x 주소&lt;/code&gt;는 메모리의 주소~주소+30 까지 정보를 16진수(x)로 출력할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b thread.c:170&lt;/code&gt; : 이것은 한 예로, thread.c의 170번째 줄에 breakpoint를 건다는 뜻이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;b 함수명&lt;/code&gt;도 가능하다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;d (숫자)&lt;/code&gt; : 숫자에 해당하는 breakpoint를 삭제한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;: 계속 진행시킨다. 다음 breakpoint에 걸리거나 프로그램이 끝날 때까지 실행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기타&quot;&gt;기타&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;내가 수강한 강좌에서는 Q&amp;amp;A를 하기 위한 piazza가 개설되어 있었는데, 여기서 필요한 정보들을 질문하거나 찾는 것이 매우 도움이 되었다. 막히는 부분이 있으면 완전한 문장의 형태로 질문을 정리하는 과정 자체가 좋은 답변과 관계없이 중요하다고 느껴졌다.&lt;/li&gt;
  &lt;li&gt;주어진 메뉴얼을 직접 이해할 때 가장 효율적이고 얻는 것도 많았다. 세세하게 짜는 과정이 나와있는 안내서를 보면 쉽지만 그 안내서에 끌려다니는 느낌이다. 나도 블로그에 PintOS를 짜는 과정을 정리해볼까 하는 생각이 들었지만, 이런 이유로 공유하지 않는게 좋겠다는 생각이 든다.&lt;/li&gt;
  &lt;li&gt;필요할 때마다 그림으로 코드의 흐름을 정리해보는 것이 큰 도움이 되었다. 전체적으로 어떤 과정이 어떻게 돌아가는지를 시각화하여 이해할 수 있고, 불필요한 과정을 잡아내기에도 좋았다.&lt;/li&gt;
  &lt;li&gt;최대한 깨끗하고 완전한, 효율적인 구현을 목표로 하자. 설계를 제대로 하지 않고 무작정 코드를 짜다가 디버깅하면 몸만 고생한다. 특히 자주 사용하는 루틴일수록 더 신경써야 한다. 코딩을 하는 시간을 최소화하고, 설계하고 구상하는 시간을 최대화하자.&lt;/li&gt;
  &lt;li&gt;여럿이서 프로젝트를 진행할 때 협업과 분업이라는 두 가지 선택지가 있다. 즉, 두 명이서 각자 독립된 부분을 완성할지, 힘을 합쳐서 한 부분을 진행할지로 나뉘어진다. 전자는 짧게 보면 고효율을 보이지만 낮은 안정성으로 디버깅에 고생할 것이고, 후자는 저효율을 보이지만 코드를 짤 때마다 즉각적으로 피드백을 받기 때문에 높은 안정성으로 디버깅에 덜 허덕인다. 나는 경험적으로 후자가 더 좋은 선택이라고 본다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><summary type="html">이번 학기에 운영체제 과목의 교육용 운영체제인 PintOS를 짜면서 느낀 점들과 초반 삽질을 줄일만한 팁들을 정리해보았다.</summary></entry><entry><title type="html">RSA LSB Oracle Attack</title><link href="http://localhost:4000/cryptography/RSA-lsb-oracle-attack/" rel="alternate" type="text/html" title="RSA LSB Oracle Attack" /><published>2020-05-11T00:00:00+09:00</published><updated>2020-05-11T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/RSA-lsb-oracle-attack</id><content type="html" xml:base="http://localhost:4000/cryptography/RSA-lsb-oracle-attack/">&lt;p&gt;암호문을 복호화해서 맨 마지막 비트(least significant bit)를 알려주는 RSA Oracle이 주어졌을 때 적용할 수 있는 공격법이다.&lt;/p&gt;

&lt;h2 id=&quot;어떻게&quot;&gt;어떻게?&lt;/h2&gt;

&lt;p&gt;RSA의 평문(plaintext)을 p, 암호문(ciphertext)을 c라고 놓았을 때, 복호화는 다음과 같이 진행된다:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \equiv c^d \mod n&lt;/script&gt;

&lt;p&gt;$c\cdot 2^e$를 같은 방식으로 복호화시켜보자.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(c \cdot 2^e)^d = c^d \cdot 2^{ed} = c^d \cdot 2^{k\phi(n)+1} \equiv 2 c^d \equiv 2p \mod n&lt;/script&gt;

&lt;p&gt;($2^{k\phi(n)+1} \equiv 2 \mod n$이 되는 부분은 편의를 위해 과감히 생략했다. &lt;a href=&quot;https://3-24.github.io/cryptography/RSA/&quot;&gt;RSA를 설명한 글&lt;/a&gt;의 복호화 증명과 완전히 동일하다.)&lt;/p&gt;

&lt;p&gt;즉, RSA Oracle에 $c \cdot 2^e$를 입력하면 2p를 n으로 나눈 나머지를 계산하고 맨 마지막 비트를 알려준다. 평문은 $n$보다 작다고 가정되므로 두 가지 경우를 고려할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;n &amp;lt; 2p &amp;lt; 2n&lt;br /&gt;
2p를 n으로 나눈 나머지는 2p-n으로, n은 언제나 홀수이기 때문에(짝수이면 n의 두 소수 인수 중 하나는 2로 고정되기 때문에 매우 위험한 RSA이므로 사용되지 않는다!) $2p-n$은 홀수이고, LSB는 1이다.&lt;/li&gt;
  &lt;li&gt;0 &amp;lt; 2p &amp;lt; n&lt;br /&gt;
2p를 n으로 나눈 나머지가 2p이기 떄문에 짝수이므로 LSB가 0이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;똑같은 방식으로 $c \cdot 4^e$를 입력하면 4p를 n으로 나눈 나머지를 계산하고 맨 마지막 비트를 알려준다. 이전 결과에 이어서 총 네 가지 경우로 나눌 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;n &amp;lt; 2p &amp;lt; 2n&lt;br /&gt;
1-1. 3n &amp;lt; 4p &amp;lt; 4n : 4p를 n으로 나눈 나머지는 4p-3n으로, LSB가 1이다.&lt;br /&gt;
1-2. 2n &amp;lt; 4p &amp;lt; 3n : 4p를 n으로 나눈 나머지는 4p-2n으로, LSB가 0이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;0 &amp;lt; 2p &amp;lt; n&lt;br /&gt;
2-1. n &amp;lt; 4p &amp;lt; 2n : 4p를 n으로 나눈 나머지는 4p-n으로, LSB가 1이다.&lt;br /&gt;
2-2. 0 &amp;lt; 4p &amp;lt; n : 4p를 n으로 나눈 나머지는 4p로, LSB가 0이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 두 번의 입력으로 가능한 p의 범위를 1/4로 줄여놓았다. 이런 식으로 계속 반복하여 가능한 p의 범위를 좁혀나가면 평문을 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;공격 예는 &lt;a href=&quot;https://github.com/ashutosh1206/Crypton/blob/master/RSA-encryption/Attack-LSBit-Oracle/README.md&quot;&gt;https://github.com/ashutosh1206/Crypton/blob/master/RSA-encryption/Attack-LSBit-Oracle/README.md&lt;/a&gt; 에 잘 정리되어 있다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="RSA" /><category term="LSB" /><summary type="html">암호문을 복호화해서 맨 마지막 비트(least significant bit)를 알려주는 RSA Oracle이 주어졌을 때 적용할 수 있는 공격법이다.</summary></entry><entry><title type="html">Length Extension Attack</title><link href="http://localhost:4000/cryptography/length-extension-attack-%EB%B3%B5%EC%82%AC%EB%B3%B8/" rel="alternate" type="text/html" title="Length Extension Attack" /><published>2020-04-04T00:00:00+09:00</published><updated>2020-04-04T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/length-extension-attack%20-%20%EB%B3%B5%EC%82%AC%EB%B3%B8</id><content type="html" xml:base="http://localhost:4000/cryptography/length-extension-attack-%EB%B3%B5%EC%82%AC%EB%B3%B8/">&lt;p&gt;Merkle-Damgard 방식의 해시 함수에 대해 적용할 수 있는 공격법이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;공격자가 모르는 메시지 m1의 해시값과 길이를 알고 있을 때, 공격자가 원하는 임의의 m2를 붙인 메시지 m1 + pad(m1) + m2의 해시값을 알 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;어떻게&quot;&gt;어떻게?&lt;/h2&gt;

&lt;p&gt;비밀 메시지 $m_1$이 패딩을 포함해서 단일 블럭으로 이루어져 있다면,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;hash(m_1) = compress(IV, m_1 \vert\vert pad_1 )&lt;/script&gt;

&lt;p&gt;이 때, 패딩을 포함한 단일 블럭의 메시지 $m_2$에 대하여, $m_3 = m_1 \vert\vert pad_1 \vert\vert m_2$를 고려하고, $Pad(m_3) = m_1 \vert\vert pad_1 \vert\vert m_2 \vert\vert pad_3$로 놓자.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;hash(m_3) = compress(compress(IV,m_1 \vert\vert pad_1 ), m_2 \vert\vert pad_3)
\\= compress(hash(m_1),m_2\vert\vert pad_3)&lt;/script&gt;

&lt;p&gt;이런 식으로 $m_1, m_2$가 단일 블럭이 아니어도, Merkle-Damgard 해시 함수의 특성 상 $hash(m_3)$를 계산할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;예를 들어, 메시지의 인증을 확인하기 위해 MAC(Message Authentication Code)로 다음과 같은 함수를 사용한다고 하자:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;secret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;SECRET!&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# message의 해시 값을 계산
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create_mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashlib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;md5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexdigest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 유저가 보낸 message의 mac 시그니처가 해시값과 일치하는지 확인
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;check_auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usermac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usermac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;어떤 웹사이트에 PHP 리퀘스트를 GET 방식으로 데이터와 시그니처를 다음과 같이 보낼 수 있다고 하자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user_id=1323&amp;amp;size=large&amp;amp;count=1&amp;amp;flavor=choco
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sign=8ccb1040d76a517033265be77f7b8506
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 때 시그니처의 길이가 32이기 때문에, 16진수 하나당 4비트이므로 128비트이고, 128비트의 출력을 하는 자주 쓰이는 암호학적 해시 함수는 MD5 정도라고 추측할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 공격자가 하고 싶은 것은 flavor를 &lt;code class=&quot;highlighter-rouge&quot;&gt;mintchoco&lt;/code&gt;로 덮는것이라고 하자.&lt;/p&gt;

&lt;p&gt;length extension attack을 적용할 때 문제는 secret의 길이를 모른다는 부분인다. 그냥 짧을 것이라고 추측해서 직접 패딩을 일일이 만들어서 직접 MD5 해시를 계산해서 인증을 시도해보고, 맞으면 secret의 길이가 7임을 알 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 m1의 길이는 51이고 한 글자는 1바이트=8비트이므로, 총 408비트이고, MD5에서 패딩을 만드는 방식에 의하면 pad1은 다음과 같이 형성된다:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1000 0000 0000 0000 0000 0000 0000 0000
0000 0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;10...0&lt;/code&gt;을 448비트가 될 때까지 채우고&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1000 1001 0001 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;408비트는 이진수로 110011000이므로 little-endian으로 채웠을 때 (총 64비트)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이걸 다 붙여서&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user_id=1323&amp;amp;size=large&amp;amp;count=1&amp;amp;flavor=choco\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00&amp;amp;flavor=mintchoco
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로 덮는다. 이 때 인증키 sign은&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;compress(8ccb1040d76a517033265be77f7b8506, &quot;&amp;amp;flavor=mintchoco&quot; + pad3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 계산해서 얻을 수 있다. 이제 pad3를 계산하고 compress를 md5 algorithm에서 가져와야 하는데..&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그냥 다른 사람이 만들어놓은 툴을 쓰자(&lt;a href=&quot;https://github.com/iagox86/hash_extender&quot;&gt;hash_extender&lt;/a&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;직접 하길 원한다면 hash_extender의 README를 읽어보는 것도 괜찮다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./hash_extender -d &quot;user_id=1323&amp;amp;size=large&amp;amp;count=1&amp;amp;flavor=choco&quot; -l 7 -a &quot;&amp;amp;flavor=mintchoco&quot; -s 8ccb1040d76a517033265be77f7b8506 -f md5
Type: md5
Secret length: 7
New signature: aed5d57ec6cb8c79b245d864665b3193
New string: 757365725f69643d313332332673697a653d6c6172676526636f756e743d3126666c61766f723d63686f636f8000000000980100000000000026666c61766f723d6d696e7463686f636f

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로 얻은 &lt;code class=&quot;highlighter-rouge&quot;&gt;sign=aed5d57ec6cb8c79b245d864665b3193&lt;/code&gt;이 이제 있다.&lt;/p&gt;

&lt;p&gt;New string을 bytearray로 바꿔서 출력해보면 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# s는 아까 얻은 New String
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;barr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bytearray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromhex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;barr&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;bytearray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;b'user_id=1323&amp;amp;size=large&amp;amp;count=1&amp;amp;flavor=choco&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x80&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x98&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x01&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;x00&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;amp;flavor=mintchoco'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(위에서 직접 손으로 패딩을 계산했던 것이 일치함을 확인할 수 있다!) 어쩄든 결과로 인증을 시도해보자.&lt;/p&gt;

&lt;p&gt;직접 secret을 붙여서 인증 서버 쪽에서 md5를 계산하면 다음과 같을 것이다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;hashlib&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashlib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;md5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;b'SECRET!'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;barr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexdigest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;'aed5d57ec6cb8c79b245d864665b3193'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해시 값이 위에서 얻은 &lt;code class=&quot;highlighter-rouge&quot;&gt;sign&lt;/code&gt;과 동일하다!&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="hash function" /><category term="Merkle-Damgard" /><category term="MD5" /><summary type="html">Merkle-Damgard 방식의 해시 함수에 대해 적용할 수 있는 공격법이다.</summary></entry><entry><title type="html">Merkle-Damgard 해시 함수</title><link href="http://localhost:4000/cryptography/Merkle-Damgard/" rel="alternate" type="text/html" title="Merkle-Damgard 해시 함수" /><published>2020-04-03T00:00:00+09:00</published><updated>2020-04-03T00:00:00+09:00</updated><id>http://localhost:4000/cryptography/Merkle-Damgard</id><content type="html" xml:base="http://localhost:4000/cryptography/Merkle-Damgard/">&lt;blockquote&gt;
  &lt;p&gt;collision-resistant한 해시 함수를 만드는 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MD5(!), SHA1, SHA2 등에 적용된다. (아쉽게도, MD5의 MD는 Message Digest의 약자라고 한다) 그림으로 표현하면 다음과 같다. IV에 메시지 블록1을 압축시키고, 그 출력에 메시지 블록2를 압축시키고 … 이를 반복하여 마지막 메시지 블록을 통과시킨다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Merkle-Damgard_hash_big.svg/1920px-Merkle-Damgard_hash_big.svg.png&quot; /&gt;
    &lt;figcaption&gt; Figure 1. MD construction의 구조 &lt;/figcaption&gt;
&lt;/div&gt;

&lt;h2 id=&quot;compression-function&quot;&gt;Compression Function&lt;/h2&gt;

&lt;p&gt;compression 함수 $f$를 가정한다. compression 함수라 함은 다음을 의미한다:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f:\{0,1\}^m \times \{0,1\}^n \to \{0,1\}^m&lt;/script&gt;

&lt;p&gt;즉, m비트와 n비트의 입력을 받아 m비트로 대응시킨다.&lt;/p&gt;

&lt;p&gt;단, 이 $f$는 출력으로부터 두 입력을 아는 것이 어려워야 하며(단방향, one-way) $f(m_1)=f(m_2)$인 서로 다른 $m_1, m_2$를 아는 것도 어려워야 한다(collision-resistant).&lt;/p&gt;

&lt;h2 id=&quot;initialization-vector&quot;&gt;Initialization Vector&lt;/h2&gt;

&lt;p&gt;처음 compression 함수에 들어가는 m비트는 IV이다.&lt;/p&gt;

&lt;h2 id=&quot;merkle-damgard-compliant-padding&quot;&gt;Merkle-Damgard Compliant Padding&lt;/h2&gt;

&lt;p&gt;메시지를 n비트 블록 단위로 쪼개어서 compression 함수에 넣기 때문에 메시지의 길이가 n비트의 단위가 아닐 경우 이를 n비트로 강제로 만드는 과정이 필요하다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Pad : \{0,1\}^* \to \{0,1\}^{n} \cup \{0,1\}^{2n} \cup \cdots&lt;/script&gt;

&lt;p&gt;MD construction의 안전성을 보장하기 위해 이 패딩함수 $Pad$에는 메시지 $M$에 대해 다음과 같은 충분조건이 존재한다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$Pad(M)$은 $M$으로 시작해야한다.&lt;/li&gt;
  &lt;li&gt;$\lvert M_1\rvert = \lvert M_2 \rvert \implies \lvert Pad(M_1) \rvert = \lvert Pad(M_2) \rvert $&lt;/li&gt;
  &lt;li&gt;$\lvert M_1\rvert  \ne \lvert M_2\rvert  \implies Pad(M_1) $의 마지막 블록 $\ne Pad(M_2)$의 마지막 블록&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;md5의-예시&quot;&gt;MD5의 예시&lt;/h2&gt;

&lt;p&gt;Merkle-Damgard construction이라는 것을 확인하기 위해 알고리즘을 다소 생략했다. 전문(&lt;a href=&quot;https://en.wikipedia.org/wiki/MD5#Pseudocode&quot;&gt;#&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Note: All variables are unsigned 32 bit and wrap modulo 2^32 when calculating
var int s[64], K[64] // predefined arrays
var int i

// Initialize variables:
var int a0 := 0x67452301   // A
var int b0 := 0xefcdab89   // B
var int c0 := 0x98badcfe   // C
var int d0 := 0x10325476   // D

// Padding 추가
append &quot;1&quot; bit to message    
// Notice: the input bytes are considered as bits strings,
//  where the first bit is the most significant bit of the byte.[50]
append &quot;0&quot; bit until message length in bits ≡ 448 (mod 512)
append original length in bits mod 2^64 to message

// Process the message in successive 512-bit chunks:
for each 512-bit chunk of padded message do
    break chunk into sixteen 32-bit words M[j], 0 ≤ j ≤ 15
    // Initialize hash value for this chunk:
    var int A := a0
    var int B := b0
    var int C := c0
    var int D := d0
    // Main loop:
    for i from 0 to 63 do
        var int F, g
        if 0 ≤ i ≤ 15 then
            F := (B and C) or ((not B) and D)
            g := i
        else if 16 ≤ i ≤ 31 then
            F := (D and B) or ((not D) and C)
            g := (5×i + 1) mod 16
        else if 32 ≤ i ≤ 47 then
            F := B xor C xor D
            g := (3×i + 5) mod 16
        else if 48 ≤ i ≤ 63 then
            F := C xor (B or (not D))
            g := (7×i) mod 16
        // Be wary of the below definitions of a,b,c,d
        F := F + A + K[i] + M[g]  // M[g] must be a 32-bits block
        A := D
        D := C
        C := B
        B := B + leftrotate(F, s[i])
    end for
    // Add this chunk's hash to result so far:
    a0 := a0 + A
    b0 := b0 + B
    c0 := c0 + C
    d0 := d0 + D
end for

var char digest[16] := a0 append b0 append c0 append d0 // (Output is in little-endian)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;따라서 MD5 Merkle-Damgard 해시 함수이다. 여기서 사용한 패딩은 다른 SHA1, SHA2와도 공유하는 방법으로, 과정은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;메시지 끝에 1을 붙인다.&lt;/li&gt;
  &lt;li&gt;그 뒤에 비트 mod 512로 448이 될 때까지 0을 붙인다. 그러면 이제 채워야 할 64비트가 남는다.&lt;/li&gt;
  &lt;li&gt;$\lvert M \rvert $를 mod $2^{64}$한 값을 little-endian 64비트 정수가 되도록 채운다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 들어, 메시지가 400비트였다면, 448비트가 될 때까지&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 붙이고&lt;/p&gt;

&lt;p&gt;400비트는 이진수로 110010000이기 때문에 little-endian은 하위 바이트가 낮은 주소로 들어와야 하므로,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0000 1001 0001 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 붙여야 한다. 즉, 4000비트 메시지의 패딩은&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 1001 0001 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 byte-array로 바꾼 &lt;code class=&quot;highlighter-rouge&quot;&gt;\x80\x00\x00\x00\x00\x00\x09\x10\x00\x00\x00\x00\x00\x00&lt;/code&gt;이다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="hash function" /><category term="Merkle-Damgard" /><summary type="html">collision-resistant한 해시 함수를 만드는 방법</summary></entry><entry><title type="html">Linux Deploy에서 부팅 시 스크립트 자동 실행하기</title><link href="http://localhost:4000/linux/linux-android-startup/" rel="alternate" type="text/html" title="Linux Deploy에서 부팅 시 스크립트 자동 실행하기" /><published>2020-03-28T00:00:00+09:00</published><updated>2020-03-28T00:00:00+09:00</updated><id>http://localhost:4000/linux/linux-android-startup</id><content type="html" xml:base="http://localhost:4000/linux/linux-android-startup/">&lt;p&gt;모바일 안드로이드 기기에서 돌리고 있는 리눅스 서버에서 부팅할 때 돌릴 프로그램을 자동으로 실행하면 번거롭게 부팅할 때마다 SSH로 접속해서 프로그램을 실행하는 과정을 생략할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;init-설정&quot;&gt;init 설정&lt;/h2&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/linux-init.png&quot; width=&quot;50%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Linux Deploy에서 속성에 들어가 init을 활성화한다.&lt;/p&gt;

&lt;h2 id=&quot;rclocal에서-돌릴-스크립트-추가&quot;&gt;rc.local에서 돌릴 스크립트 추가&lt;/h2&gt;

&lt;p&gt;SSH로 접속한 서버 쉘을 열어서 다음을 입력한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /etc
$ mkdir rc.local
$ cd rc.local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(만약 이미 rc.local이 있다면 그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;cd /etc/rc.local&lt;/code&gt;)을 하면 된다.&lt;/p&gt;

&lt;p&gt;이제 여기서 부팅할 때 실행할 쉘 스크립트 파일을 만든다. 파일 이름 startScript는 다른 이름으로 해도 무관하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vim startScript
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 다음은 나의 예시로, 각자 원하는 목적에 맞춰서 쉘 스크립트를 입력해야 한다. 주의해야 할 점은, startScript는 부팅할 때 루트 계정으로 실행된다는 것이다. 따라서 다른 계정의 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt;에 설정해놓은 환경 변수 등도 적용이 되지 않는다. 내가 원했던 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/workspace/discordbots/run.sh&lt;/code&gt;를 루트 계정이 아닌, 필요한 환경 변수들이 설정된 &lt;code class=&quot;highlighter-rouge&quot;&gt;youngseok&lt;/code&gt; 계정으로 실행하는 것이었고 이는 다음과 같이 작성된다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
su youngseok &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'bash /home/youngseok/workspace/discordbots/run.sh'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이걸 저장하고 서버를 재시작하면 스크립트에 문제가 없다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;startScript&lt;/code&gt;가 실행되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; start
Check file system ... done
Mounting the container:
/ ... done
/proc ... done
/sys ... done
(생략됨)
:: Starting services:
startScript ... done
&amp;lt;&amp;lt;&amp;lt; start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Linux" /><category term="rc.local" /><summary type="html">모바일 안드로이드 기기에서 돌리고 있는 리눅스 서버에서 부팅할 때 돌릴 프로그램을 자동으로 실행하면 번거롭게 부팅할 때마다 SSH로 접속해서 프로그램을 실행하는 과정을 생략할 수 있다.</summary></entry><entry><title type="html">루팅된 안드로이드 기기를 리눅스 서버로 사용하기</title><link href="http://localhost:4000/linux/linux-android/" rel="alternate" type="text/html" title="루팅된 안드로이드 기기를 리눅스 서버로 사용하기" /><published>2020-03-28T00:00:00+09:00</published><updated>2020-03-28T00:00:00+09:00</updated><id>http://localhost:4000/linux/linux-android</id><content type="html" xml:base="http://localhost:4000/linux/linux-android/">&lt;p&gt;모바일 기기는 전력 소모가 적고 성능도 무난하기 때문에 소형 프로젝트를 돌릴 만한 서버로 적합하다. 루팅된 개인 모바일 안드로이드 기기를 개인 리눅스 서버로 탈바꿈하는 과정을 정리해보았다.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;안드로이드 기기의 루트 권한&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Busybox 앱 설치(&lt;a href=&quot;https://play.google.com/store/apps/details?id=ru.meefik.busybox&amp;amp;hl=en&quot;&gt;#&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;Linux Deploy 앱 설치(&lt;a href=&quot;https://play.google.com/store/apps/details?id=ru.meefik.linuxdeploy&amp;amp;hl=en&quot;&gt;#&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;busybox-설치&quot;&gt;Busybox 설치&lt;/h2&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/linux_deploy/busybox.png&quot; width=&quot;50%&quot; /&gt;
&lt;figcaption&gt; &lt;br /&gt;Figure 1. Busybox 설치&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;busybox는 리눅스에서 ls, cp 등 자주 사용하는 명령어들만 모아놓은 상자라고 볼 수 있다. 안드로이드 기본 커널에서 제공하는 명령어가 제한적이기 때문에 서버로 사용할 배포판 리눅스를 설치하기 앞서 busybox를 설치해주어야 한다. 해당 앱을 열고 설치를 누르고 루트 권한을 허용해주면 알아서 설치해준다.&lt;/p&gt;

&lt;h2 id=&quot;linux-deploy-설정&quot;&gt;Linux Deploy 설정&lt;/h2&gt;

&lt;p&gt;deploy 앱을 열어 리눅스를 설치하기 전에 기본적인 설정들을 하자.&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/linux_deploy/linux_deploy_with_number.png&quot; width=&quot;50%&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;&lt;figcaption&gt; Figure 2. Linux Deploy 설정&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;왼쪽 메뉴(1)를 열어 설정에서&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Wakelock 체크 : 기기를 잠금시켰을 때 안드로이드에서 전력 소모를 막기 위해 앱을 종료하거나 느려지게 만드는 기능을 해제한다. 서버로 사용할 목적이기 때문에 필수.&lt;/li&gt;
  &lt;li&gt;자동시작 체크 : 안정정인 기기면 상관없겠지만, 필자의 기기는 가끔씩 아무 이유없이 재부팅된다. 부팅하고 알아서 리눅스 서버가 켜지도록 하는 설정이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오른쪽 아래에 속성 아이콘(2)을 눌러서&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배포에서 리눅스 배포판 선택 : Ubuntu&lt;/li&gt;
  &lt;li&gt;사용자 이름, 비밀번호 설정 : 앞으로 이 글에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;{id}&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;{passwd}&lt;/code&gt;로 대체할 것이다.&lt;/li&gt;
  &lt;li&gt;지역화 : en_US.UTF-8&lt;/li&gt;
  &lt;li&gt;SSH 활성화 : 포트도 설정하고 싶다면 바꿔주자. 이 글에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;{port}&lt;/code&gt;로 대체한다. 기본적으로는 22를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 다시 처음 화면으로 돌아가서 오른쪽 위에 메뉴(3)를 열어 설치를 누르면 된다. 꽤 오래 걸리니 조급해하지 말고 밖에 나가서 밀린 설거지나 하고 돌아오자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 끝나면 설치가 완료되었다는 뜻이다.&lt;/p&gt;

&lt;h2 id=&quot;ssh-연결&quot;&gt;SSH 연결&lt;/h2&gt;

&lt;p&gt;이제 START 버튼을 눌러 서버를 가동해주자. 화면 위쪽에 있는 아이피를 확인하고 이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;{ip}&lt;/code&gt;로 부르겠다. &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.0.4&lt;/code&gt; 이런 형태일 것이다. 위에서 설정한 &lt;code class=&quot;highlighter-rouge&quot;&gt;{id}&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;{passwd}&lt;/code&gt;도 여기서 사용된다.&lt;/p&gt;

&lt;p&gt;Mac이나 Linux같이 shell이 제공된다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh {id}@{ip}&lt;/code&gt;를, ssh 포트를 따로 설정했다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh {id}@{ip} -p {port}&lt;/code&gt;를 shell에서 입력하면 연결이 된다.&lt;/p&gt;

&lt;p&gt;Windows라면 ssh에 접속하는 클라이언트를 사용한다. 필자는 &lt;a href=&quot;https://github.com/iPuTTY/iPuTTY/releases&quot;&gt;iPutty&lt;/a&gt;를 사용중이다. 호스트 이름에 &lt;code class=&quot;highlighter-rouge&quot;&gt;{id}@{ip}&lt;/code&gt;를 입력하고 포트도 바꿔놨다면 그 옆에 입력한다. 이제 “열기”를 누르면 쉘이 켜진다.&lt;/p&gt;

&lt;p&gt;(별다른 설정을 안해놨다면 같은 네트워크에 접속되어있을 때만 연결이 가능하다)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Using username &quot;{id}&quot;,
{id}@{ip}'s password:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 {passwd}를 입력하면 로그인이 되면서 서버 쉘을 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Welcome to Ubuntu 18.04 LTS (GNU/Linux 3.10.49-g5ae7f00 aarch64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

Ubuntu 18.04 LTS [running via Linux Deploy]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="Linux" /><summary type="html">모바일 기기는 전력 소모가 적고 성능도 무난하기 때문에 소형 프로젝트를 돌릴 만한 서버로 적합하다. 루팅된 개인 모바일 안드로이드 기기를 개인 리눅스 서버로 탈바꿈하는 과정을 정리해보았다.</summary></entry><entry><title type="html">\[픽셀 아트\] 자화상</title><link href="http://localhost:4000/pixel%20art/pixelart/" rel="alternate" type="text/html" title="\[픽셀 아트\] 자화상" /><published>2020-03-28T00:00:00+09:00</published><updated>2020-03-28T00:00:00+09:00</updated><id>http://localhost:4000/pixel%20art/pixelart</id><content type="html" xml:base="http://localhost:4000/pixel%20art/pixelart/">&lt;div style=&quot;text-align: center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/pixel_art/me.jpg&quot; width=&quot;70%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;나를 그려보았다. 손을 흔들고 있는 왼손은 뭔가 애매하지만 커피잔을 들고 있는 오른손이 잘 전달된다.&lt;/p&gt;</content><author><name>Youngseok Choe</name><email>dev.youngseok@gmail.com</email></author><category term="pixel art" /><summary type="html"></summary></entry></feed>