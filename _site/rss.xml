<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Three Dash Two Four</title>
    <description>수학과 개발을 오가며</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 22 May 2021 04:34:56 +0900</pubDate>
    <lastBuildDate>Sat, 22 May 2021 04:34:56 +0900</lastBuildDate>
    <generator>Jekyll v3.9.1</generator>
    
      <item>
        <title>쌍을 포함하는 부분구간수열의 개수 세기</title>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;

&lt;p&gt;0과 1로 이루어진 수열 a가 있다. 이 수열의 부분구간수열을 a의 시작과 마지막부분에서 각각 0개 이상의 원소를 빼서 만들어지는 수열이라고 하자. 이 수열의 각 부분구간수열이 가지는 (1,1)의 쌍의 개수를 구해야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 수열이 [0, 1, 1, 0, 1]이라면, [1,1], [0, 1, 1], [1, 1, 0], [0, 1, 1, 0], [1, 0, 1]은 1개, [1, 1, 0, 1], [0, 1, 1, 0, 1]은 3개의 (1,1)쌍을 포함하므로, 총 11개이다.&lt;/p&gt;

&lt;p&gt;알고리즘의 시간복잡도는 수열의 길이 N에 대해 선형이어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;풀이&lt;/h2&gt;

&lt;p&gt;먼저, 모든 부분구간수열에 대해 (1,1)쌍의 개수를 세려면 부분구간수열의 총 개수가 $O(N^2)$이므로 요구되는 시간에 맞출 수가 없다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/2aiUv2f.png&quot; width=&quot;80%&quot; /&gt;
    &lt;figcaption&gt; Figure 1. 각 (1,1)쌍에 대해 그 쌍을 포함하는 구간의 개수 &lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;또, 각 (1,1) 쌍에 대해 그 쌍을 포함하는 부분구간수열의 개수를 세는 방법이 있는데, 그것 또한 (1,1) 쌍의 개수가 $O(N^2)$이기 때문에 부족하다. 하지만 Figure 1처럼 (1,1)쌍의 두 번째 1의 인덱스가 같은 것끼리 비교하면 공통점이 보이기 시작한다. 두 번째와 세 번째는 모두 (N-x3)가 곱해지고, 네 번째부터 마지막까지는 (N-x4)가 곱해진다.&lt;/p&gt;

&lt;p&gt;두 번째 1의 인덱스를 기준으로 개수를 세면&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 번째 1의 인덱스가 x2인 각 (1,1)에 대해 이를 포함하는 구간의 개수는 $(x_1 + 1)(N-x_2)$&lt;/li&gt;
  &lt;li&gt;두 번째 1의 인덱스가 x3인 각 (1,1)에 대해 이를 포함하는 구간의 개수는 $(x_1 +1 + x_2 + 1)(N-x_3)$&lt;/li&gt;
  &lt;li&gt;두 번째 1의 인덱스가 x4인 각 (1,1)에 대해 이를 포함하는 구간의 개수는 $(x_1 +1 + x_2 + 1+x_3+1)(N-x_4)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 식으로 마지막 1에 도달할 때까지 계속 반복해서 더해나가면 된다.&lt;/p&gt;

&lt;p&gt;각 경우에 대해 $(N-x_i)$는 바로 계산 가능하고, $\sum_{i=1} ^m {x_i} + m$은 &lt;strong&gt;구간 합(prefix sum)&lt;/strong&gt;을 이용하면 바로 계산 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;								&lt;span class=&quot;c1&quot;&gt;// 입력의 길이&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;						&lt;span class=&quot;c1&quot;&gt;// 1의 인덱스를 저장하는 벡터&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ll&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ll&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;psum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;psum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;psum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 22 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/algorithm/1/</link>
        <guid isPermaLink="true">http://localhost:4000/algorithm/1/</guid>
        
        <category>algorithm</category>
        
        <category>counting</category>
        
        <category>prefix sum</category>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Jekyll - 올바른 RSS가 아닙니다 (네이버 서치어드바이저)</title>
        <description>&lt;p&gt;블로그의 유입을 늘리려고 이 블로그를 네이버 서치어드바이저에 검색 등록을 하다가 &lt;a href=&quot;https://3-24.github.io/feed.xml&quot;&gt;https://3-24.github.io/feed.xml&lt;/a&gt;의 RSS 제출에서 올바르지 않은 RSS라고 거부당했는데 원인을 알려주지 않아서 꽤 당혹스러웠습니다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/img/search_error.png&quot; /&gt;
    &lt;figcaption&gt; Figure 1. 오류 창 &lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;조사해보니까 피드 파일을 생성하는 jekyll-feed 플러그인이 Atom 문법으로 feed.xml 파일을 생성하는데, 서치 어드바이저는 RSS를 요구해서 생기는 문제였습니다. Atom은 RSS보다 가지는 이점이 몇 개 존재하는 더 진보된 양식이고, 점점 Atom의 점유율이 높아지는 추세이긴 합니다만, 네이버에서 아직 지원을 하지 않는 것 같습니다. 그래서 &lt;a href=&quot;https://jekyllcodex.org/without-plugin/rss-feed/#&quot;&gt;Jekyll Codex에 나온 RSS 피드를 수동으로 만든 방법&lt;/a&gt;에서 feed.xml 파일 이름만 rss.xml로 살짝 바꿔서 두 가지 피드를 제공하기로 했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://3-24.github.io/feed.xml]&quot;&gt;https://3-24.github.io/feed.xml&lt;/a&gt;은 정식으로 사용하는 Atom 피드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://3-24.github.io/rss.xml&quot;&gt;https://3-24.github.io/rss.xml&lt;/a&gt;은 RSS 피드&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;빌드 시간이 더 오래걸리겠지만 검색엔진 등록을 위해서는 어쩔 수 없는 것 같습니다.&lt;/p&gt;

</description>
        <pubDate>Thu, 03 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/scribbles/naver-search-atom/</link>
        <guid isPermaLink="true">http://localhost:4000/scribbles/naver-search-atom/</guid>
        
        
        <category>Scribbles</category>
        
      </item>
    
      <item>
        <title>x86-64 시스템의 i386 아키텍처 호환에 관한 고찰</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;이 글은 리눅스에서 바이너리와 호환 아키텍처에 관해 찾아보면서 알게 된 것들을 정리한 글입니다. 오류가 있을 수도 있으니 만약에 있다면 너그럽게 알려주시길 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가끔 오래된 바이너리를 보면 별도의 설정 없이 실행을 할 때 다음과 같이 오류를 출력한다. 분명 존재하는 파일인데 왜 없다고 뜨는걸까.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./bof
bash: ./bof: No such file or directory
$ file ./bof
bof: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=ed643dfe8d026b7238d3033b0d0bcc499504f273, not stripped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그래서 file 명령어로 확인해보면 32비트 바이너리라고 하는데, 왜 실행이 안되나 하고 찾아봤더니 &lt;a href=&quot;https://askubuntu.com/questions/454253/how-to-run-32-bit-app-in-ubuntu-64-bit&quot;&gt;해당 답변&lt;/a&gt;에서는 i386 아키텍처와 관련된 libc 라이브러리를 설치하라고 한다:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;dpkg &lt;span class=&quot;nt&quot;&gt;--add-architecture&lt;/span&gt; i386
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get update
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;libc6:i386 libncurses5:i386 libstdc++6:i386
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;물론 문제는 해결이 되지만, 아키텍처의 개념과, i386의 의미, 그리고 바이너리가 왜 실행이 안되었는지에 관해 의문이 남아서 열심히 공부하면서 찾아보았다.&lt;/p&gt;

&lt;p&gt;‘컴퓨터 아키텍처’란 흔히 기계어라고 불리는 명령어 집합(Itruction Set Assembly)에 이를 회로로 구현하는데 사용하는 마이크로아키텍처와 하드웨어 구성을 의미한다. 그리고 x86은 인텔이 개발한 CPU 시리즈와 명령어 집합을 통칭하는 말로, 이름이 x86인 이유는 초기 프로세서들 이름이 8086, 80186, 80286 등 다 86으로 끝나서였다고 한다. 그 중에서도 처음으로 32비트를 지원하는 CPU가 인텔 i386인데, 후에 인텔의 32비트 CPU 컴퓨터 아키텍처 IA-32는 다 이 i386을 기준으로 만들어졌기 때문에 i386 아키텍처는 IA-32를 통칭한다고 볼 수도 있는 것 같다.&lt;/p&gt;

&lt;p&gt;하지만 32비트는 메모리 주소를 32비트밖에 사용할 수 없으므로, $2^{32}$바이트, 즉 4기가바이트의 메모리까지만 접근이 가능하다는 한계가 있었고, 더 나아가기 위해 64비트 CPU를 개발하기 위해 IA-32의 확장이 여러 개 제안되었다. 이 중 인텔이 완전히 새롭게 설계하여 IA-32와 호환되지 않는 IA-64와, IA-32와 호환되면서 64비트 명령을 추가한 AMD의 x86-64(또는 AMD64)가 있었다. x86-64가 시장의 선택을 받았고, 이후 인텔도 x86-64를 AMD로부터 라이선스를 받아 구현하면서 IA-64는 사실상 사장되고 x86-64가 표준이 되었다고 한다.&lt;/p&gt;

&lt;p&gt;일단 내가 사용하는 리눅스 시스템의 아키텍처는 다음과 같이 x86-64로 확인되었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ uname -p
x86_64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;x86-64 CPU로 i386 프로그램을 실행할 수 있는데 왜 실행이 되지 않는가.. 좀 더 찾아보니 elf 헤더를 읽어보면 다음과 같은 정보가 있다고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ readelf -a ./bof
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x530
  Start of program headers:          52 (bytes into file)
  Start of section headers:          4428 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         9
  Size of section headers:           40 (bytes)
  Number of section headers:         30
  Section header string table index: 27
 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;즉 Machine이 Intel 80386, 즉 i386을 가리키고, 또한 해당 프로그램이 요구하는 라이브러리를 살펴보면,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ldd ./bof
linux-gate.so.1 (0xf7f65000)
libc.so.6 =&amp;gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d60000)
/lib/ld-linux.so.2 (0xf7f67000)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;역시 i386-linux-gnu 하위의 libc 라이브러리가 필요하다. 따라서 저 라이브러리를 dpkg로 설치하기 위해서 apt 패키지 저장소에서 libc를 설치해줘야 했던 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install libc6:i386
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 실행해줘야 한다. 하지만 이를 하기 위해서는 패키지 저장소에 있는 i386 패키지 목록을 받아와야 하므로, 사용하는 아키텍처에 i386을 추가한 다음 apt update를 해줘야 한다. 그리고 이가 가능한 이유는 x86-64가 i386의 명령어 집합을 처리하기 때문이다. 만약 ARM 아키텍처가 요구되는 프로그램이었다면 별도의 에뮬레이터 없이는 실행이 불가능했을 것이다.&lt;/p&gt;

&lt;p&gt;정리하자면, 해당 바이너리는 i386 CPU를 요구하는데, x86-64 아키텍처는 커널과 라이브러리의 도움을 받아 i386 바이너리를 실행할 수도 있다. 이를 가능하게 해주는 것이 dpkg을 i386 아키텍처를 추가하여 libc 라이브러리를 설치하게 해주는 것이다. 아직 ELF 프로그램이 실행되는 구체적인 과정 등 완전히 의문이 해소된 것은 아니지만, 이 정도면 그럭저럭 만족할만한 설명을 얻은 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;참고-문서&quot;&gt;참고 문서&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9%EC%96%B4_%EC%A7%91%ED%95%A9&quot;&gt;IA-32, Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%A7%91%ED%95%A9&quot;&gt;명령어 집합, Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] &lt;a href=&quot;https://ko.wikipedia.org/wiki/X86&quot;&gt;x86, Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4] &lt;a href=&quot;https://ko.wikipedia.org/wiki/X86-64&quot;&gt;x86-64, Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5] &lt;a href=&quot;https://wiki.debian.org/Multiarch/HOWTO&quot;&gt;Multiarch, HOWTO - Debian Wiki&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 01 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/system/arch-elf-study/</link>
        <guid isPermaLink="true">http://localhost:4000/system/arch-elf-study/</guid>
        
        <category>Architecture</category>
        
        <category>x86_64</category>
        
        <category>i386</category>
        
        
        <category>System</category>
        
      </item>
    
      <item>
        <title>2020년 여름학기 몰입캠프 후기</title>
        <description>&lt;p&gt;봄학기 종강을 하자마자 카이스트에서 여름학기로 열리는 몰입캠프에 참여했기 때문에 한동안 정말 바빴다. 어제 몰입캠프 종강을 한 지금, 이 캠프에 참여하면서 얻은 것들을 정리해보고자 한다. 이 후기를 쓰고 있는 나는 카이스트 전산학부지만, 타대생과 컴공이 아닌 다른 전공을 하고 있는 수강생도 많이 볼 수 있었다.&lt;/p&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://madcamp.io/&quot;&gt;몰입캠프 메인페이지&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/document/d/1flSaJ4kGRzkpxTTlRNqA7bOC0oI7idQR3PXPnMt9b-g/edit&quot;&gt;2020년 여름학기 몰입캠프 강의계획서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실라버스를 보면 알 수 있듯, 완전히 개발 프로젝트 중심의 수업이다. 4주동안 각 주마다 프로젝트 하나를 2~3인 팀을 구성하여 진행하게 된다. 매 주 프로젝트 발표를 마친 후 투표를 하여 금주의 픽으로 선택되면 전체 수강생들 앞에서 한 번 더 발표를 하게 되는 영광을 누릴 수 있다. 금주의 픽 발표가 끝나면 스타트업 관계자가 들려주는 생생한 창업 스토리나 프로젝트에 사용될만한 기술, 개발 방법론 등을 들을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;프로젝트&quot;&gt;프로젝트&lt;/h2&gt;

&lt;p&gt;프로젝트를 위해 20명으로 구성된 각 반마다 실습실 하나를 사용하게 된다. 인당 모니터 두 대와 쓸만한 성능의 컴퓨터를 사용하게 된다.&lt;/p&gt;

&lt;p&gt;이 수업을 듣기 전에 나는 개발 중에 사용한 대부분의 프로그래밍 언어나 프레임워크로 개발한 경험은 없지만, CTF 문제를 풀어보면서 기본적인 서버와 데이터베이스 개념과 몇 가지 문법을 이용해본 적이 있는 정도였다. 그래서 사용하는 기술에 대한 적응은 빠른 편이었던 것 같다. 혼자서는 한 주 만에 절대 하지 못했을 것 같지만 주변에 물어볼 사람도 많고 다 같이 몰입하며 열심히 하는 분위기가 형성되기 때문에 나도 놀랄 정도로 많은 기술들을 공부하고 적용해볼 수 있었다.&lt;/p&gt;

&lt;p&gt;각 프로젝트에서 세부적으로 했던 일들은 다음과 같다. 자랑할만 하지는 않지만 프로젝트 소스코드도 같이 올려놓았다.&lt;/p&gt;

&lt;h3 id=&quot;1주차&quot;&gt;1주차&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/3-24/madcamp1&quot;&gt;영석이의 하루 Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;안드로이드 앱 개발을 한다. 탭1에는 사용자의 연락처 목록을 받아와 연락처 화면을 구성하고, 탭2에는 사진을 받아와서 갤러리 화면을 구성한다. 마지막 탭3은 자유 주제로, 나는 날씨 API에서 현재 위치하고 있는 지역의 날씨 정보를 받아와 일기예보를 보여주는 화면을 만들었다. 사용하는 언어나 프레임워크는 자유이고, 나를 포함한 대부분의 사람들은 기본 안드로이드 자바 프로그래밍을 하였다.&lt;/p&gt;

&lt;h3 id=&quot;2주차&quot;&gt;2주차&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/3-24/madcamp2&quot;&gt;밤편지 프런트엔드 Github&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/3-24/madcamp2_backend&quot;&gt;밤편지 백엔드 Github&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;안드로이드 앱 개발은 그대로이지만, 서버와 데이트베이스 기술을 적용해야 한다. 탭1과 탭2의 형식은 연락처와 갤러리로 동일하나 서버와 상호작용하는 부분을 추가해야 한다. 나는 1주차 때 했던 탭1 탭2 구성을 똑같이 하고 싶지 않아서 간단한 SNS 서비스를 만들어 탭1을 친구 목록, 탭2를 피드로 대체하였다. 새로운 개발 프레임워크를 경험하고 싶어서 React Native를 이용해보았고, 백엔드 서버는 NodeJS와 MySQL 데이터베이스를 사용하였다.&lt;/p&gt;

&lt;h3 id=&quot;3주차&quot;&gt;3주차&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/CatDominatesWorld/CatDominatesWorld&quot;&gt;고양이가세계를지배한다냥 프런트엔드 Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/CatDominatesWorld/CatDominatesWorld-backend&quot;&gt;고양이가세계를지배한다냥 백엔드 Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://github.com/CatDominatesWorld/CatDominatesWorld/blob/master/asset/demo.png?raw=true&quot; width=&quot;90%&quot; /&gt;
    &lt;figcaption&gt; Figure 1. 위키피디아 COVID-19 문서에 적용한 모습 &lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;자유 주제&lt;/strong&gt;. 나는 웹 페이지에 표시되는 모든 텍스트를 ‘냥’과 ‘meow’로 바꾸고, 모든 사진에서 얼굴을 인식하면 고양이 얼굴로 바꾸는 크롬 익스텐션을 만드는 프로젝트를 하였다. 크롬 익스텐션 쪽은 HTML/CSS와 Javascript를 이용하여, 그리고 자연어 처리와 얼굴 인식을 하여 변환 부분을 담당하는 백엔드 서버는 Python 3기반으로, 통신은 Flask, 이미지 프로세싱은 OpenCV, 자연어 처리는 konlpy와 nltk 라이브러리, 얼굴 인식은 카카오 Vision API를 사용하였다.&lt;/p&gt;

&lt;h3 id=&quot;4주차&quot;&gt;4주차&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;자유 주제&lt;/strong&gt;. Unreal Engine을 이용해 3차원 잠입 액션 게임을 만들었다. 언리얼 엔진은 애니메이션 하나만 추가해도 150MB만큼의 용량을 요구하기 때문에(…) Github를 통해 관리하다가 포기했다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/img/phantom_sight.png&quot; width=&quot;90%&quot; /&gt;
    &lt;figcaption&gt; Figure 2. Phantom Sight - 3차원 잠입 액션 게임 &lt;/figcaption&gt;
&lt;/div&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;한 달 동안 같은 실습실에서 밤을 새면서 개발을 하기 때문에 다 같이 친해지게 된다. 식사나 술자리를 자주 가졌고, 심지어 엠티를 다녀오기도 했다. 정말 착하고 좋은 다양한 사람들을 만나서 4주 내내 행복했다. 신청을 할 때를 돌이켜 생각해보면 정말 여러가지 동기가 복합적으로 작용했었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 명이 참여하는 개발 프로젝트를 경험하고, 개발 역량을 키우기 위해서&lt;/li&gt;
  &lt;li&gt;방학을 의미있게 보내고 싶어서&lt;/li&gt;
  &lt;li&gt;개발에 관심이 있는 새로운 사람을 만나고 싶어서&lt;/li&gt;
  &lt;li&gt;스타트업 생태계에 대한 생생한 정보를 듣고 싶어서&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결과적으로 내가 기대했던 것들을 다 얻을 수 있었고, 정말 잊지 못할 방학이 될 것 같다. COVID-19로 어려움이 있음에도 불구하고 이런 기회를 준 교수님들, 강연자분들과 같은 공간에서 같이 밤을 샌 반 동료들에게 감사한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/scribbles/madcamp-review/</link>
        <guid isPermaLink="true">http://localhost:4000/scribbles/madcamp-review/</guid>
        
        <category>madcamp</category>
        
        
        <category>Scribbles</category>
        
      </item>
    
      <item>
        <title>단일프로세서 스케줄링</title>
        <description>&lt;p&gt;사용할 수 있는 CPU는 유한하지만 운영체제는 여러 개의 일task를 한꺼번에 작동시켜야 한다. 그래서 운영체제에서 일이 CPU를 점유하는 시간을 관리해주는 부분이 필요한데, 이를 스케줄러scheduler라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;performace-metric&quot;&gt;Performace Metric&lt;/h2&gt;

&lt;p&gt;어떤 방식의 스케줄링을 사용하는 것을 고민하기 전에, 그 스케줄링이 얼마나 효율적인지를 나타내는 지표들을 정리해보았다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;throughput: 시간당 처리가 끝나는 일의 수&lt;/li&gt;
  &lt;li&gt;turnaround time: 일이 완전히 처리될 때까지 걸리는 시간 ($T_{fin} - T_{arrival}$)&lt;/li&gt;
  &lt;li&gt;response time: 일이 처음 반응하기까지 걸리는 시간 ($T_{response} - T_{arrival}$)&lt;/li&gt;
  &lt;li&gt;waiting time: ready, wait상태에서 일이 기다린 시간의 합&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;특정 스케줄러로 여러 일을 처리했을 때 위 네 지표가 낮다면 그것은 효율적인 스케줄러이다.&lt;/p&gt;

&lt;p&gt;문제의 단순화를 위해 프로세서가 하나만 있는 경우에 대해서만 다룬다.&lt;/p&gt;

&lt;h2 id=&quot;1-fifo&quot;&gt;1. FIFO&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;먼저 오는 일을 먼저 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가장 먼저 생각해볼만한 방법이다. 먼저 오는 일을 먼저 처리한다. (First-In-First-Out)&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler01.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. FIFO Scheduling
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;하지만 시간이 오래 걸리는 일이 먼저 처리되고, 시간이 적게 걸리는 일에 나중에 처리되면 성능이 급격히 하락한다. 예를 들면 P1, P2, P3, P4가 시간이 각각 20, 4, 3, 3만큼 거리는 일이라고 하고, 이들이 시간 0에 P1, P2, P3, P4 순서대로 FIFO 스케줄러에 도달했다고 하자. 그러면 Figure 1과 같이 스케줄링될 것이다. 그러면 총 turnaround time=20+24+27+30=91, 총 response time=0+20+24+27=71, 총 waiting time=0+20+24+27=71이다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler02.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 2. Optimal Scheduling
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;만약에 Figure 2와 같이 스케줄링되었다면 총 turnaround time=3+6+10+30=49, 총 response time=0+3+6+10=19, 총 waiting time=0+3+6+10=19가 된다. 이와 같이 FIFO 방식으로 스케줄링 했을 때 오래 걸리는 일이 나머지 일의 처리를 지연시키는 상황을 convoy effect라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스케줄러의 계산량이 적다. 이전 일의 처리가 끝날 때마다 ready queue에서 첫 번째 일을 running state로 보내버리면 된다.&lt;/li&gt;
  &lt;li&gt;같은 이유로 구현이 간단하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;성능이 나쁘다. convoy effect에 의해 평균 response time, 평균 turnaround time, 평균 waiting time 모두 높다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-shortest-job-first-sjf&quot;&gt;2. Shortest Job First (SJF)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;남은 시간이 가장 짧은 일을 먼저 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler02.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 2. SJF Scheduling (Recall)
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Figure 2와 같이, &lt;strong&gt;남은 시간이 가장 짧은 일을 먼저 처리하는 방식&lt;/strong&gt;이다. 가능한 스케줄링 방식 중에 평균 waiting time이 가장 낮다. 하지만 언제나 시간이 적게 걸리는 일을 시간이 많이 걸리는 일보다 먼저 처리하기 때문에, 시간이 적게 걸리는 일이 계속 쿼리될 경우 시간이 많이 걸리는 일이 먼저 쿼리되었음에도 불구하고 계속 처리가 지연된다. 이런 현상을 &lt;strong&gt;starvation&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지표 상 성능이 좋다. 최소의 평균 waiting time을 보장하고, 평균 response time, 평균 turnaround time 모두 빠른 편에 속한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;starvation이 발생한다.&lt;/li&gt;
  &lt;li&gt;완벽한 구현이 불가능하다. 일반적으로 스케줄러가 특정 일을 처리하기 전에 그 일이 얼마나 걸리는 지 확인할 방법이 없다. 그래서 그 일이 얼마나 걸릴지 이전 일들이 걸린 시간을 통해 유추하는 방법을 사용한다. 스케줄링은 운영체제에서 자주 일어나는 일이기 때문에 높은 계산량을 요구하는 유추 알고리즘은 사용할 수 없고, 이전 일들이 걸린 시간들의 단순한 선형 관계 정도의 유추 전략이 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;starvation을-해결하는-방법&quot;&gt;Starvation을 해결하는 방법&lt;/h3&gt;

&lt;p&gt;SJF 스케줄링은 남은 시간을 priority(우선도)로 적용한 스케줄링 방식이다. 일반적으로 priority scheduling에서는 priority가 낮은 일이 priority가 높은 일에 비해 우선순위가 밀려서 처리되지 않는 starvation이 발생하는 것이 문제가 된다. 그래서 starvation을 해결하기 위해 다음 기법을 사용한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Aging&lt;/strong&gt;: 프로세스가 오랫동안 기다릴수록 priority를 높인다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 starvation 문제를 해결하더라도 SJF는 어디까지나 ‘이론적인 스케줄러’일 뿐이다.&lt;/p&gt;

&lt;h2 id=&quot;3-round-robin&quot;&gt;3. Round Robin&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;각 일이 정해진 시간 동안만 실행되는 FIFO&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;FIFO지만, 각 일이 특정 시간 동안만 CPU를 점유할 수 있는&lt;/strong&gt; 스케줄링 방식이다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler03.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 3. Round Robin Scheduling
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Figure 3는 time slice가 2로 설정되었을 때 스케줄링이 어떤 방식으로 이루어지는지를 보여준다. SJF와 달리 starvation도 발생하지 않고, FIFO에서 발생하는 convoy effect도 발생하지 않는다. 이렇게 보기에는 쓸만한 스케줄러 같지만, time slice의 크기에 따라 문제가 발생한다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler04.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 4. Too Short Time Slice
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;time slice가 너무 짧아서 FIFO에 비해 response time은 짧지만 나머지 지표가 좋지 않다. Figure 4에서 Round Robin의 모든 프로세스가 FIFO의 모든 프로세스보다 늦거나 같게 끝난다는 것을 확인할 수 있다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler05.png&quot; width=&quot;80%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 5. Too Long Time Slice
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;한편, time slice가 너무 길면 Figure 5와 같이 I/O에 늦게 반응하게 된다. 정리해보면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;task가 대부분 CPU의 처리로 이루어진 CPU-bound task라면 time slice가 길어질수록 효율이 좋다. Figure 4에서 논한 문제는 time slice가 짧아서 발생하였다.&lt;/li&gt;
  &lt;li&gt;task가 대부분 I/O를 기다리는 I/O-bound task라면 time-slice가 짧아야 한다. 만약 time slice가 길다면 입력과 출력에 반응하는 시간이 오래 걸린다. (response time 중시)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본적으로 FIFO이기 때문에 starvation이 발생하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;time slice의 설정 방법에 따라, 그리고 스케줄링되는 task의 속성에 따라 성능이 달라진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;돌아보기&quot;&gt;돌아보기&lt;/h2&gt;

&lt;p&gt;지금까지 FIFO, SJF, Round Robin 스케줄링을 알아보았다. 그 과정에서 각자 발생하는 장점과 단점이 있었는데 이들을 모아서 이상적인 스케줄러의 특성을 나열하면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SJF처럼 짧게 걸리는 일을 빨리 처리해야한다.&lt;/li&gt;
  &lt;li&gt;특정 task가 오랫동안 실행되지 않는 starvation이 발생해서는 안된다.&lt;/li&gt;
  &lt;li&gt;스케줄링을 하는데 걸리는 시간이 오래걸려서는 안된다.&lt;/li&gt;
  &lt;li&gt;CPU-bound task에 대해서 turnaround time을 줄여야 하고, I/O-bound task에 대해서 response time을 줄여야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-multi-level-feedback-queue-mfq&quot;&gt;4. Multi-Level Feedback Queue (MFQ)&lt;/h2&gt;

&lt;p&gt;최종적으로 이 글에서 소개할, 가장 발전된 형태의 uniprocessor 스케줄링 방식이다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/scheduler/scheduler06.png&quot; width=&quot;60%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 6. MFQ Scheduling
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;각자 독립된 priority를 가진 round robin 큐를 만든다. 높은 priority를 가진 큐를 rounb robin 방식으로 스케줄링하고, 종료되지 않은 프로세스를 한 단계 낮은 priority를 가진 큐에 넣는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SJF 처럼 짧게 걸리는 일이 빨리 처리되는가? 예&lt;/p&gt;

    &lt;p&gt;오래 걸리는 일은 round robin 큐를 여러 개 거치면서 priority가 낮아지기 때문에 짧게 걸리는 일이 우선적으로 처리된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;starvation이 발생하지 않는가? 아니오 -&amp;gt; 예(해결 가능)&lt;/p&gt;

    &lt;p&gt;스케줄러가 높은 priority의 큐를 우선적으로 처리하기 때문에 낮은 priority의 큐에 있는 일이 오랫동안 처리되지 않는 starvation이 발생할 우려가 있다. 이 문제는 aging을 이용하면 해결된다. 매번 기다리는 상태에 있는 task를 한 단계 더 높은 priority를 가지는 큐에 넣어주면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스케줄링을 하는데 많은 양의 계산을 요구하지 않는가? 예&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CPU-bound task의 turnaround time이 적은가? 아니요-&amp;gt;예(해결 가능)&lt;/p&gt;

    &lt;p&gt;priority가 낮아질수록 round robin의 time slice를 높이면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I/O-bound task의 reponse가 빠른가? 예&lt;/p&gt;

    &lt;p&gt;만약 많은 양의 CPU의 처리가 요구되는 CPU-bound task가 들어온다면, 여러 큐를 거쳐가면서 priority가 낮아지는 반면, I/O-bound task의 경우 프로세서에서 처리하는 시간이 적어 priority가 잘 낮아지지 않기 때문에 높은 priority에 머무른다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 20 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/system/scheduler-policy/</link>
        <guid isPermaLink="true">http://localhost:4000/system/scheduler-policy/</guid>
        
        <category>scheduler</category>
        
        <category>FIFO</category>
        
        <category>SJF</category>
        
        <category>round robin</category>
        
        <category>MFQ</category>
        
        
        <category>System</category>
        
      </item>
    
      <item>
        <title>파일 인덱싱 구조</title>
        <description>&lt;p&gt;운영체제에서 파일시스템은 유저가 파일 이름을 통해서 디스크의 물리적 주소에 저장된 데이터에 접근하는 것을 가능하게 해준다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파일 이름은 각 디렉토리에서 접근하려는 파일의 여러가지 정보를 담고 있는 메타데이터(inode)로 변환되고&lt;/li&gt;
  &lt;li&gt;메타데이터를 통해 필요한 데이터가 저장된 디스크의 블럭을 찾아내어 물리적 주소를 통해 접근한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 글에서는 2번에서 어떤 indexing structure을 통해 어떤 방식으로 메타데이터에 디스크의 블럭 주소들이 저장되는지를 알아볼 것이다. 유저가 사용하는 파일과 디스크에 저장된 데이터에 대해 다음과 같은 특징이 존재한다는 것을 기억하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디스크에 있는 데이터는 블럭 단위로 관리된다.&lt;/li&gt;
  &lt;li&gt;한 파일이 반드시 디스크에서 연속적으로 저장된다는 보장이 없다. fragmentation을 방지하기 위해 높은 확률로 이곳저곳에 쪼개져 있을 것이다.&lt;/li&gt;
  &lt;li&gt;유저가 파일에 접근할 때 파일의 데이터를 연속적으로 읽기도 하고, 랜덤하게 읽기도 한다.&lt;/li&gt;
  &lt;li&gt;파일의 크기는 변할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linked-list&quot;&gt;Linked List&lt;/h2&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/uploads/linkedListAllocation.jpg&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. Linked List File Allocation [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;디스크에 있는 각 블럭이 다음 블럭의 포인터를 저장하고 있다. 파일의 메타데이터는 첫 번째 블럭을 가리킨다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;순차적 접근이 빠르다.&lt;/li&gt;
  &lt;li&gt;구현이 간단하다.&lt;/li&gt;
  &lt;li&gt;쉽게 블럭을 추가하고 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;무작위 접근이 느리다. (크기가 작은 파일의 경우 캐시를 통해 해결 가능하다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메타데이터에는 파일의 첫 번째 블럭 포인터만 저장되기 때문에 임의의 n번째 블럭에 도달하기 위해서 n개의 블럭을 직접 지나야 한다. 따라서 무작위 접근을 할 때 속도가 캐시 메모리에 의존도가 높기 때문에 크기가 작은 파일들을 주로 관리할 때 적합한 파일시스템이다. 실제로 FAT 파일시스템은 파일을 linked list로 관리하는데, USB와 같은 작은 디스크에서 자주 사용된다.&lt;/p&gt;

&lt;h2 id=&quot;array&quot;&gt;Array&lt;/h2&gt;

&lt;p&gt;각 파일의 메타데이터가 모든 블럭 주소를 적어놓은 배열을 가진다. 배열이라는 자료구조의 장점과 단점을 그대로 답습한다.&lt;/p&gt;

&lt;p&gt;장점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구현이 간단하다.&lt;/li&gt;
  &lt;li&gt;순차적 접근, 무작위 접근 모두 빠르다.&lt;/li&gt;
  &lt;li&gt;쉽게 블럭을 추가하고 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;배열의 크기로 파일의 최대 크기가 고정된다&lt;/strong&gt;. 즉, 유동적인 파일 크기 변화가 불가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파일의 최대 크기를 늘리자고 배열의 크기를 모든 파일에 대해서 크게 설정할 수도 없는 노릇이다. 파일시스템으로 사용할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;multi-level-indexing&quot;&gt;Multi-level Indexing&lt;/h2&gt;

&lt;p&gt;배열의 단점을 보완한 방법이다. 해당 방법을 이용하는 파일 시스템으로는 Berkeley UNIX FFS가 있는데, inode에 15개의 블럭 포인터가 저장되어 있다. 이 블럭 포인터들은 디스크에 저장된 다른 블럭 포인터의 주소를 저장할 수도 있고, 바로 물리적 디스크 주소를 저장할 수도 있다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/uploads/Combined-Scheme.jpg&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 2. Multi-level indexing [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;FFS를 기준으로, 첫 번째 12개의 포인터들은 바로 데이터가 담긴 블럭을 가리킨다. 각 블럭이 4KB일 때,  최대 48KB까지 수용할 수 있다.&lt;/p&gt;

&lt;p&gt;13번째 포인터는 indirect 블럭 포인터인다. 이 포인터는 데이터 포인터들을 담고 있는 디스크의 블럭을 가리킨다. 즉, 가리키고 있는 블럭의 크기는 4KB이고, 물리적 주소가 32비트라고 했을 때 이는 4바이트이므로 가리키고 있는 블럭에 최대 1K개의 포인터를 수용할 수 있다. 이 1K개의 포인터는 각각 다른 4KB 짜리 데이터가 저장된 블럭을 가리키므로, 1K와 4KB를 곱해서 최대 4MB의 데이터가 수용 가능하다.&lt;/p&gt;

&lt;p&gt;14번째 포인터는 doubly indirect 블럭 포인터이다. 이 포인터가 가리키고 있는 블럭은 1K의 indirect 블럭을 가리키는데, 각각의 indirect 블럭은 최대 4MB의 데이터가 수용 가능하므로 1K와 4MB를 곱한 4GB의 데이터가 수용 가능하다.&lt;/p&gt;

&lt;p&gt;마지막인 15번째 포인터는 triply indirect 블럭 포인터로, 같은 방식으로 4TB의 데이터가 수용 가능하다.&lt;/p&gt;

&lt;p&gt;이렇게 총 4KB+4MB+4GB+4TB의 데이터를 저장하고 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;장점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;무작위 접근, 순차적 접근 모두 좋다.&lt;/li&gt;
  &lt;li&gt;용량의 제한이 거의 느껴지지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구현이 복잡하다.&lt;/li&gt;
  &lt;li&gt;파일에 접근할 때 디스크에서 여러 번의 indirection을 반복하면 느려진다. (캐시로 보완 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://www.geeksforgeeks.org/file-allocation-methods/&quot;&gt;GeeksforGeeks - File Allocation Methods&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/system/file-indexing/</link>
        <guid isPermaLink="true">http://localhost:4000/system/file-indexing/</guid>
        
        <category>file system</category>
        
        
        <category>System</category>
        
      </item>
    
      <item>
        <title>디렉토리의 구조</title>
        <description>&lt;p&gt;파일시스템에서 유저가 특정 파일명에서 오프셋 위치에 있는 데이터에 접근하려고 할 때 실제 디스크에 접근하기 위해 일어나는 일은 두 단계로 나뉜다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파일명으로부터 디스크에 저장되어있는 inode를 찾아서 읽는다.&lt;/li&gt;
  &lt;li&gt;inode와 오프셋으로부터 해당 파일에서 오프셋 위치에 있는 블럭의 디스크상의 물리 주소를 구한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/img/directory/image01.png&quot; width=&quot;90%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. inode and inode Array
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;여기서 inode(information node)는 실제 데이터의 포인터와 기타 정보들을 담고 있는 데이터로, 디스크에서 위와 같이 inode array의 형태로 관리된다.&lt;/p&gt;

&lt;p&gt;이 글에서는 1번을 용이하게 만들어주는 &lt;strong&gt;디렉토리&lt;/strong&gt;에 대해서 다루려고 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;디렉토리도 일종의 파일이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;디렉토리도 파일과 크게 다르지 않다. 디렉토리도 그 디렉토리가 포함하는 하위 파일/디렉토리 정보를 디스크에 저장하고, 그 위치를 탐색하기 위해 해당 디렉토리의 inode 또한 디스크에 저장된다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/home/minus21/workspace/app01/main.py&lt;/code&gt;라는 파일에 접근하는 상황을 생각해보자. 루트 디렉토리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt;는 inode 인덱스가 고정되어있기 때문에 inode를 찾아낼 수 있고, 이 inode를 통해 하위 디렉토리들의 이름이 inode 인덱스로 다음과 같이 매핑된다. (이 매핑을 구현하기 위해 다양한 자료구조가 사용될 수 있다)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name | inode index
-----|-------------
bin  | 737
usr  | 924
home | 14
proc | 47
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러면 home의 inode 인덱스 14로부터 inode에 접근할 수 있고, 이 inode가 가리키는 블럭에는 또 같은 형태의 매핑이 존재한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name   | inode index
-------|-------------
minus21| 287
user01 | 894
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 식으로 반복하여 최종적으로 app01 디렉토리의 inode에 접근하고, 이 inode가 가리키는 블럭에 저장된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.py&lt;/code&gt;라는 파일의 inode를 찾아내어 위에 적은 2번 과정을 하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;큰-디렉토리&quot;&gt;큰 디렉토리&lt;/h2&gt;

&lt;p&gt;디스크는 블럭 단위(4KB)로 정보가 관리되는데, 디렉토리의 하위 파일/디렉토리가 아주 많아서 정보가 4KB를 넘어가면 어떻게 될까? 이 범람을 해결하기 위해서는 한 디렉토리를 여러 블럭으로 관리해야 하는데, 디렉토리를 접근하는 다음 두 상황을 모두 고려해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일명(또는 디렉토리명)으로부터 파일에 해당하는 inode를 찾는다.&lt;/li&gt;
  &lt;li&gt;디렉토리 내부의 파일(또는 디렉토리)들을 빠르게 순서대로 탐색할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, 쉽게 말해서 무작위 접근, 순차적 접근 모두 빨라야 한다. 그래서 디렉토리를 구현할 때 B+ 트리와 같은 형태가 사용될 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] 2020 Spring CS330 Operating System Lecture of KAIST&lt;/p&gt;

</description>
        <pubDate>Thu, 18 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/system/directory/</link>
        <guid isPermaLink="true">http://localhost:4000/system/directory/</guid>
        
        <category>file system</category>
        
        <category>directory</category>
        
        
        <category>System</category>
        
      </item>
    
      <item>
        <title>Substitution-Permuation Network</title>
        <description>&lt;p&gt;DES가 대표적인 Feistel cipher 형태의 블록 암호 알고리즘이었지만 취약한 것으로 알려지면서 미국이 공모전을 통해 새로 제정한 블록 암호 알고리즘이 있는데, 바로 SP-network 형태의 AES이다. (사실 DES도 유사 SP 과정을 Feristel 암호의 round function으로 사용한다)&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/cd/SubstitutionPermutationNetwork2.png&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. 3단계 SP Network 암호 [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;암호화&quot;&gt;암호화&lt;/h2&gt;

&lt;h3 id=&quot;s-box&quot;&gt;S-box&lt;/h3&gt;

&lt;p&gt;S가 치환substitution의 약자인만큼, 입력 비트를 일정한 길이로 쪼개서 그 각각을 &lt;strong&gt;같은 길이&lt;/strong&gt;의 비트로 치환시킨다. 복호화도 가능하게 하기 위해서 &lt;strong&gt;one-to-one&lt;/strong&gt; 관계를 유지해야 한다. Figure 1에서 16비트 평문을 4비트씩 쪼개서 치환시키는 것이 이에 해당한다. S-box는 비선형성이 보장된다.&lt;/p&gt;

&lt;h3 id=&quot;p-box&quot;&gt;P-box&lt;/h3&gt;

&lt;p&gt;P는 비트를 섞는 과정이다. permutation의 약자로, Figure 1에서 P 상자를 자세히 보면 세 번째 비트가 첫 번째 비트가 되고, 14번째 비트가 16번째 비트가 되는 것들을 볼 수 있을 것이다. 이는 입력 비트를 x 벡터, 출력 비트를 y 벡터로 표현했을 때 y=Ax가 되는 행렬 A가 간단하게 존재하므로 선형이다. 또한, 이 비트를 섞는 과정을 역으로 언제나 수행할 수 있고 이는 복호화해서 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;key&quot;&gt;Key&lt;/h3&gt;

&lt;p&gt;매 라운드마다 비밀 키와 XOR시킨다.&lt;/p&gt;

&lt;h2 id=&quot;복호화&quot;&gt;복호화&lt;/h2&gt;

&lt;p&gt;앞에서 서술했듯 S-box와 P-box에 역함수의 존재성이 보장되므로 암호화하는 과정을 역함수를 이용해서 거꾸로 진행하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] Wikipedia - Substitution-permutation network&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cryptography/SP-network/</link>
        <guid isPermaLink="true">http://localhost:4000/cryptography/SP-network/</guid>
        
        <category>SP network</category>
        
        <category>block cipher</category>
        
        
        <category>Cryptography</category>
        
      </item>
    
      <item>
        <title>PintOS를 짜면서 정리해본 팁과 설정들</title>
        <description>&lt;p&gt;이번 학기에 운영체제 과목의 교육용 운영체제인 PintOS를 짜면서 느낀 점들과 초반 삽질을 줄일만한 팁들을 정리해보았다.&lt;/p&gt;

&lt;p&gt;반드시 꼭 설정해야 할 중요한 알맹이들만 있지는 않고, 프로그래밍을 하다가 지쳤을 때 재미로 설정한 것들도 다수 있다.&lt;/p&gt;

&lt;h2 id=&quot;1-git&quot;&gt;1. Git&lt;/h2&gt;

&lt;p&gt;PintOS는 KAIST에서는 2인 1조로 작업하였고, 협업을 하기 위해서는 &lt;strong&gt;Git을 사용을 안할 수가 없었다&lt;/strong&gt;. 잘 안되서 예전에 짰던 코드로 돌려놓고 싶을 때도 많고, 병렬적으로 팀원과 다른 부분을 구현하여 나중에 합쳐야 하는 경우도 있는데 Git을 사용하면 이 작업들이 쉽게 이루어질 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가장 많이 쓰는 명렁어: git commit, git push, git pull, git status&lt;/li&gt;
  &lt;li&gt;branch 관리 : git checkout, git branch, git merge&lt;/li&gt;
  &lt;li&gt;기타 커밋로그 관리 : git rebase, git reset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Git 저장소로는 대중적인 Github에 비공개 레퍼지토리를 만들어서 관리하였다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/04.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 1. 정말로 화난다면 이런 커밋을 할 수도 있겠지만..&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;나중에 커밋로그를 읽고 팀원이 리뷰를 할 때 힘들어하지 않도록 &lt;a href=&quot;https://meetup.toast.com/posts/106&quot;&gt;좋은 git 커밋 메시지를 작성하기 위한 7가지 약속&lt;/a&gt;을 읽어보고 지키는 것을 추천한다. 내가 요구했던 것은 세 가지였다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기본적인 커밋 메시지 convention을 지키자. 어떤 변화가 있었는지 요약을 담고, 필요에 따라 추가적인 설명을 작성해야 좋은 커밋 메시지이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;커밋을 하기 전에 &lt;strong&gt;최소한 컴파일은 제대로 되는지, 통과했던 테스트케이스가 실패했는지&lt;/strong&gt;를 반드시 확인해주자. 커밋 할 때마다 확인을 하지 않고 한꺼번에 디버깅하면 시간만 많이 잡아먹는다.&lt;/li&gt;
  &lt;li&gt;디버깅을 위해 넣은 printf, ASSERT는 미래에 사용될 일이 없다면 삭제해주자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;브랜치는 큰 변경점이 있거나 새로운 프로젝트를 시작할 때마다 만들어두면 좋다.&lt;/p&gt;

&lt;h2 id=&quot;2-에디터&quot;&gt;2. 에디터&lt;/h2&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/01.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 2. Vim은 정말 좋은 에디터입니다&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;처음에는 습관대로 리눅스 쉘에서 vim을 통해 코드를 관리했지만, 운영체제와 같은 대형 프로젝트를 CLI를 고집하면서 달랑 vim을 통해 관리하는 것에는 현실적인 어려움이 있었다. 소스 파일들, 헤더 파일들, 테스트 코드, 테스트 출력, 컴파일하고 실행시킬 쉘, 디버깅을 할 쉘 등 여러 창을 띄어놓고 해야 하는 만큼 GUI의 직관성과 효율성을 무사하기 힘들다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/02.jfif&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 3. vscode로 관리할 때&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;그래서 Visual Studio Code를 제공된 개발 서버에 원격으로 연결하여 작업했는데 정말 혁명적이었다. 설정은 &lt;a href=&quot;https://code.visualstudio.com/docs/remote/ssh&quot;&gt;Visual Studio Code - Remote Development using SSH&lt;/a&gt;를 참고하였다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl+P&lt;/code&gt;와 같은 몇몇 자주 사용하는 단축키들을 익혀놓으면 효율이 더 올라갈 것이다.&lt;/p&gt;

&lt;h2 id=&quot;3-커뮤니케이션&quot;&gt;3. 커뮤니케이션&lt;/h2&gt;

&lt;p&gt;온라인으로 프로젝트에 대해 이슈를 나누고 서로 피드백해줄 수단이 필요하다. 나는 COVID-19의 영향으로 모든 협업이 온라인으로 진행되었기 때문에 더 의존했던 것 같다. 내 팀은 화면 공유까지 지원하는 Discord를 사용하였다. Slack은 메시지 수 제한도 있고, 화면 공유를 지원하지 않는 것 같아서 선택하지 않았던 것 같다(사실 잘 안써봐서 모른다).&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/03.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 4. Github-Discord webhook&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;또한 Github를 사용한다면 Discord에서 웹훅을 걸 수 있다. 이 작업을 한다면 git push를 할 때마다 디스코드 채널에 자동으로 알림이 가게 된다. 같은 브랜치에서 두 팀원이 작업을 하고 있을 때 git pull을 하지 않아 충돌이 잦았는데, 이렇게 알림을 설정하면 그런 문제를 최소화할 수 있다. 각자 커밋을 할때마다 바로 리뷰를 해줄 수도 있었다. 웹훅을 설정하는 방법은 &lt;a href=&quot;https://gist.github.com/eslachance/40ac1c8232a5a019b43ee3f588d637ad&quot;&gt;Github Gist - Github to Discord Webhook Tutorial&lt;/a&gt;를 참고하라. Slack에도 비슷한 기능이 있던 것으로 기억한다.&lt;/p&gt;

&lt;h2 id=&quot;4-디버깅&quot;&gt;4. 디버깅&lt;/h2&gt;

&lt;p&gt;처음에는 gdb를 사용하지 않고 printf와 ASSERT만을 이용하여 짰는데, 뒤로 갈수록 gdb를 사용하는 것이 필수적이었으며, 앞에서도 gdb를 쓸 줄 알았다면 얼마나 좋았을까 하는 생각이 들었다. 심지어 일부 과정에서는 printf가 프로그램의 흐름을 방해하여 정상적으로 디버깅할 수 없는 경우도 있었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디버깅의 안정성 gdb &amp;gt; ASSERT &amp;gt; printf&lt;/li&gt;
  &lt;li&gt;난이도: gdb « ASSRET = printf&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/img/pintos_tips/gdb.png&quot; width=&quot;100%&quot; /&gt;
    &lt;figcaption&gt;Figure 5. gdb&lt;/figcaption&gt;
&lt;/div&gt;

&lt;p&gt;PintOS를 gdb에 연결하는 작업은 아마 각 프로젝트 메뉴얼에 안내가 되어 있을 것이고, 이 글에서는 자주 사용하는 gdb 명령어만 간략하게 정리해보았다. 더 자세한 내용은 검색을 통해 알아보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; : 소스 코드의 다음 줄을 실행시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt; : 소스 코드의 다음 명령을 실행시킨다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt;는 함수를 한 줄로 간주하여 실행하는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt;은 함수 안에 있는 한 줄을 실행시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p (대상)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x (대상)&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(대상)&lt;/code&gt;은 주소 또는 변수명이 될 수 있다. 그 대상이 갖고 있는 정보를 확인할 때 사용한다. x보다는 p를 자주 사용하는 편. 어떤 방식으로, 어느 만큼 출력할지도 결정할 수 있다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x/30x 주소&lt;/code&gt;는 메모리의 주소~주소+30 까지 정보를 16진수(x)로 출력할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b thread.c:170&lt;/code&gt; : 이것은 한 예로, thread.c의 170번째 줄에 breakpoint를 건다는 뜻이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b 함수명&lt;/code&gt;도 가능하다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d (숫자)&lt;/code&gt; : 숫자에 해당하는 breakpoint를 삭제한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;: 계속 진행시킨다. 다음 breakpoint에 걸리거나 프로그램이 끝날 때까지 실행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기타&quot;&gt;기타&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;내가 수강한 강좌에서는 Q&amp;amp;A를 하기 위한 piazza가 개설되어 있었는데, 여기서 필요한 정보들을 질문하거나 찾는 것이 매우 도움이 되었다. 막히는 부분이 있으면 완전한 문장의 형태로 질문을 정리하는 과정 자체가 좋은 답변과 관계없이 중요하다고 느껴졌다.&lt;/li&gt;
  &lt;li&gt;주어진 메뉴얼을 직접 이해할 때 가장 효율적이고 얻는 것도 많았다. 세세하게 짜는 과정이 나와있는 안내서를 보면 쉽지만 그 안내서에 끌려다니는 느낌이다. 나도 블로그에 PintOS를 짜는 과정을 정리해볼까 하는 생각이 들었지만, 이런 이유로 공유하지 않는게 좋겠다는 생각이 든다.&lt;/li&gt;
  &lt;li&gt;필요할 때마다 그림으로 코드의 흐름을 정리해보는 것이 큰 도움이 되었다. 전체적으로 어떤 과정이 어떻게 돌아가는지를 시각화하여 이해할 수 있고, 불필요한 과정을 잡아내기에도 좋았다.&lt;/li&gt;
  &lt;li&gt;최대한 깨끗하고 완전한, 효율적인 구현을 목표로 하자. 설계를 제대로 하지 않고 무작정 코드를 짜다가 디버깅하면 몸만 고생한다. 특히 자주 사용하는 루틴일수록 더 신경써야 한다. 코딩을 하는 시간을 최소화하고, 설계하고 구상하는 시간을 최대화하자.&lt;/li&gt;
  &lt;li&gt;여럿이서 프로젝트를 진행할 때 협업과 분업이라는 두 가지 선택지가 있다. 즉, 두 명이서 각자 독립된 부분을 완성할지, 힘을 합쳐서 한 부분을 진행할지로 나뉘어진다. 전자는 짧게 보면 고효율을 보이지만 낮은 안정성으로 디버깅에 고생할 것이고, 후자는 저효율을 보이지만 코드를 짤 때마다 즉각적으로 피드백을 받기 때문에 높은 안정성으로 디버깅에 덜 허덕인다. 나는 경험적으로 후자가 더 좋은 선택이라고 본다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 15 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/scribbles/pintos-tips/</link>
        <guid isPermaLink="true">http://localhost:4000/scribbles/pintos-tips/</guid>
        
        
        <category>Scribbles</category>
        
      </item>
    
      <item>
        <title>Feistel Cipher</title>
        <description>&lt;p&gt;Feistel 암호는 블록 암호의 일종이다. DES가 대표적이다.&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/f/fa/Feistel_cipher_diagram_en.svg&quot; width=&quot;40%&quot; style=&quot;background-color:white;&quot; /&gt;
    &lt;p&gt;
        Figure 1. Feistel 암호의 암호화와 복호화 [1]
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;후술할 암호화와 복호화 과정은 위 그림 하나로 다 설명된다. 암호화할 때 $f$라는 라운드 함수를 사용하는데, 암호화할 때나 복호화할 때나 공통적으로 $f^{-1}$도 아닌 $f$를 그대로 사용한다! 즉, 어떤 형태의 $f$를 제안해도 그것으로 블록 암호를 만들 수 있다는 자유도가 있다. 그리고 암호화하는 과정과 복호화하는 과정이 닮아있기 때문에 시간도 같게 걸린다.&lt;/p&gt;

&lt;h2 id=&quot;암호화&quot;&gt;암호화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;입력: 암호화할 $L_0 \vert\vert R_0$ 블록, 공통적으로 사용할 비밀키 $k_0, \cdots , k_{r-1} $&lt;/li&gt;
  &lt;li&gt;출력: r번의 라운드 함수를 거쳐서 만들어진 $L_r \vert\vert R_r $ 블록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본적이므로 블록 암호이므로 고정된 길이의 입력 $L_0 \vert\vert R_0$을 암호화하는 과정을 살펴볼 것이다. $L_0$와 $R_0$의 길이는 같다.&lt;/p&gt;

&lt;p&gt;r-round Feistel 암호는 이 블록을 매 단계마다 다음과 같이 암호화한다:&lt;/p&gt;

\[(L_{i+1}, R_{i+1}) = (R_i, L_i \oplus f(R_i, k_i)) \quad \text{for } i=0,2,\cdots,r-1\]

&lt;p&gt;여기서 $f$를 라운드 함수round function이라고 부르고, 이 라운드 함수에 사용되는 $k_i$는 i번째 비밀 키이다.&lt;/p&gt;

&lt;p&gt;이렇게 r개의 라운드를 거쳐서 나오는 $R_r \vert\vert L_r$이 암호화된 블록이다.&lt;/p&gt;

&lt;h2 id=&quot;복호화&quot;&gt;복호화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;입력: 복호화할 $L_r \vert\vert R_r$ 블록, 공통적으로 사용할 비밀키  $k_0, \cdots , k_{r-1} $&lt;/li&gt;
  &lt;li&gt;출력: $L_0 \vert\vert R_0$ 평문 블록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;암호화와 똑같은 과정을 뒤집어서 수행한다.&lt;/p&gt;

\[(R_i, L_i) = (L_{i+1},R_{i+1}\oplus f(L_{i+1},k_i)) \quad \text{for } k=0,1,\cdots,r-1\]

&lt;h2 id=&quot;검증&quot;&gt;검증&lt;/h2&gt;

&lt;p&gt;r-round Feistel의 복호화 과정이 정확한 지 확인하고 싶다면, 다음을 확인하면 된다. E와 D는 각각 암호화encrypt와 복호화decrypt를 의미한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$(L_{i+1}, R_{i+1}) = E(L_i, R_i) = (R_i, L_i \oplus f(R_i, k_i))$&lt;/li&gt;
  &lt;li&gt;$(L_i’, R_i’) = D(L_{i+1}, R_{i+1})=(R_{i+1} \oplus f(L_{i+1}, k_i)), L_{i+1} )$&lt;/li&gt;
  &lt;li&gt;$(L_i’,R_i ‘) = (L_i, R_i)$인가?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;먼저, $R_i’ = L_{i+1} = R_i$임은 쉽게 확인된다.&lt;/p&gt;

\[L_i' = R_{i+1} \oplus f(L_{i+1}, k_i) = (L_i \oplus f(R_i,k_i)) \oplus f(L_{i+1}, k_i) = L_i \oplus (f(R_i, k_i) \oplus f(L_{R_i, k_i})) = L_i\]

&lt;p&gt;따라서 각 단계마다 복호화가 유효하다는 것이 확인되었고, 이 단계들로 구성된 r-round Fesistel 암호의 전체 복호화 과정도 정확하다.&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;p&gt;[1] Wikipedia - Feistel Cipher&lt;/p&gt;

</description>
        <pubDate>Mon, 15 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cryptography/Feistel-cipher/</link>
        <guid isPermaLink="true">http://localhost:4000/cryptography/Feistel-cipher/</guid>
        
        <category>Feistel</category>
        
        <category>block cipher</category>
        
        
        <category>Cryptography</category>
        
      </item>
    
  </channel>
</rss>
